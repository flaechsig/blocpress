= blocpress Product Backlog
:revnumber: 1.0
:revdate: {docdate}
:toc:
:toc-title: Inhaltsverzeichnis
:icons: font
:numbered:

Dieses Dokument bildet das Product Backlog von blocpress ab. Es leitet sich aus der
xref:specification/arc42.adoc[Architekturdokumentation] und dem
xref:specification/Element_Design_Concept.adoc[Element Design Concept] ab.

*Legende:*

[cols="1,3" options="header"]
|===
| Status | Bedeutung
| icon:check-circle[role=green] DONE | Implementiert und getestet
| icon:play-circle[role=blue] IN PROGRESS | In Bearbeitung
| icon:circle-o[] OFFEN | Noch nicht begonnen
|===

<<<
[[epic-1]]
== Epic 1: Document Rendering Engine

_Module: blocpress-core, blocpress-render_

Kern-Engine zur Dokumentengenerierung aus ODT-Templates und JSON-Daten.
Einzige Ã¶ffentlich exponierte API des Systems.

[cols="1,3,1,1" options="header"]
|===
| Ref | Story | Prio | Status

| TF-5
| Merge-Pipeline (Text-BlÃ¶cke, Bedingungen, Schleifen, Feldersetzung)
| 1
| icon:check-circle[role=green] DONE

| TI-3
| LibreOffice headless Export (ODT -> PDF/RTF)
| 1
| icon:check-circle[role=green] DONE

| TI-1
| REST-API: `POST /render/template/upload` (Multipart)
| 1
| icon:check-circle[role=green] DONE

| TI-1
| REST-API: `POST /render/template` (JSON/Base64)
| 1
| icon:check-circle[role=green] DONE

| TI-4
| JWT-Authentifizierung (konfigurierbar via ENV)
| 1
| icon:check-circle[role=green] DONE

| â€”
| Swagger UI (`/q/swagger-ui`)
| 2
| icon:check-circle[role=green] DONE

| â€”
| Docker Image mit Healthcheck
| 2
| icon:check-circle[role=green] DONE

| â€”
| Quickstart-Samples und Landing Page
| 3
| icon:check-circle[role=green] DONE

| UC-10
| Template-ID-basiertes Rendering (`POST /render/{id}`)
| 2
| icon:check-circle[role=green] DONE

| â€”
| Asynchrone Generierung ueber Message Queue
| 3
| icon:circle-o[] OFFEN
|===

<<<
[[epic-2]]
== Epic 2: Template Storage und Persistence

_Module: blocpress-render, blocpress-core_

Datenbankanbindung und Storage Abstraction Layer als Grundlage fuer
Template-Verwaltung und Stufenuebergabe.

NOTE: Voraussetzung fuer Epics 3-6.

[cols="1,3,1,1" options="header"]
|===
| Ref | Story | Prio | Status

| TI-2
| PostgreSQL Multi-Schema Setup (workbench, proof, production, admin)
| 1
| icon:circle-o[] OFFEN

| â€”
| Storage Abstraction Layer (`StorageService` Interface)
| 1
| icon:circle-o[] OFFEN

| â€”
| Entity E-1 (Template) und E-3 (generiertes Dokument)
| 1
| icon:circle-o[] OFFEN

| â€”
| Repository Layer fuer Schema `production` in blocpress-render
| 1
| icon:circle-o[] OFFEN
|===

<<<
[[epic-3]]
== Epic 3: Template-Entwicklung (blocpress-workbench)

_Modul: blocpress-workbench_

Arbeitsumgebung fuer Template-Designer: Upload, Validierung, Bearbeitung,
Bausteinverwaltung und Content Search.

[cols="1,3,1,1" options="header"]
|===
| Ref | Story | Prio | Status

| UC-1
| Template hochladen und validieren
| 1
| icon:check-circle[role=green] DONE

| TF-1
| Template-Validierung (User-Fields, Wiederholungsgruppen, Bedingungen)
| 1
| icon:check-circle[role=green] DONE

| UC-3
| Template-Details anzeigen
| 2
| icon:check-circle[role=green] DONE

| UC-2
| Template zur Freigabe einreichen (Stufenuebergabe workbench -> proof)
| 2
| icon:check-circle[role=green] DONE

| UC-5
| Template Management Dashboard mit Status-Filtern und Workflow
| 2
| icon:check-circle[role=green] DONE

| UC-20
| Testdaten-Generator aus Template-Feldern
| 2
| icon:check-circle[role=green] DONE

| UC-21
| Mehrere Test-Datensaetze pro Template verwalten
| 2
| icon:check-circle[role=green] DONE

| TF-8
| PDF-Speicherung als "expected result" fuer Regression-Tests
| 2
| icon:check-circle[role=green] DONE

| UC-11
| Regression-Test durchfuehren (Ist-PDF vs. expected PDF)
| 3
| icon:circle-o[] OFFEN

| â€”
| Bausteinverwaltung (Entity E-2)
| 2
| icon:circle-o[] OFFEN

| UC-19
| Content Search (Volltextsuche ueber alle Templates)
| 3
| icon:circle-o[] OFFEN

| TI-7
| Elasticsearch-Integration
| 3
| icon:circle-o[] OFFEN
|===

<<<
[[epic-4]]
== Epic 4: Pruefung und Freigabe (blocpress-proof)

_Modul: blocpress-proof_

Workflow-gesteuerte Qualitaetssicherung mit Vier-Augen-Prinzip,
Regressionstests und Compliance-Reviews.

[cols="1,3,1,1" options="header"]
|===
| Ref | Story | Prio | Status

| UC-8
| Template freigeben (Vier-Augen-Prinzip)
| 1
| icon:circle-o[] OFFEN

| TF-2
| Workflow-Status aendern (Designer != Freigeber erzwungen)
| 1
| icon:circle-o[] OFFEN

| â€”
| Stufenuebergabe proof -> production (Kopie)
| 1
| icon:circle-o[] OFFEN

| UC-14
| Test Case erstellen (Baseline-PDF)
| 2
| icon:circle-o[] OFFEN

| UC-16
| Regressionstest ausfuehren
| 2
| icon:circle-o[] OFFEN

| TF-6
| PDF-Vergleich (Baseline vs. aktuell)
| 2
| icon:circle-o[] OFFEN

| UC-12
| Compliance-Review durchfuehren
| 3
| icon:circle-o[] OFFEN

| TF-4
| Review-Datum berechnen (1/3/5 Jahre)
| 3
| icon:circle-o[] OFFEN

| TF-7
| Automatische Compliance-Review-Ueberwachung (Scheduler)
| 3
| icon:circle-o[] OFFEN

| TI-5
| Message Queue fuer asynchrone Regressionstests
| 3
| icon:circle-o[] OFFEN
|===

<<<
[[epic-5]]
== Epic 5: Administration (blocpress-admin)

_Modul: blocpress-admin_

Benutzerverwaltung, Rollenzuweisung und Audit-Logging.

[cols="1,3,1,1" options="header"]
|===
| Ref | Story | Prio | Status

| UC-22
| Benutzerverwaltung (CRUD, Rollenzuweisung)
| 1
| icon:circle-o[] OFFEN

| â€”
| Entity E-9 (Users) und E-10 (Audit-Logs)
| 1
| icon:circle-o[] OFFEN

| â€”
| RBAC-Pruefung bei jedem API-Call
| 2
| icon:circle-o[] OFFEN

| â€”
| Audit-Logging aller Workflow-Aenderungen
| 2
| icon:circle-o[] OFFEN
|===

<<<
[[epic-6]]
== Epic 6: Portal und Micro-Frontends (blocpress-studio)

_Modul: blocpress-studio_

Portal-Shell als zentraler Einstiegspunkt mit Micro-Frontend-Integration
der SCS-Module.

[cols="1,3,1,1" options="header"]
|===
| Ref | Story | Prio | Status

| â€”
| Portal-Shell (Navigation, JWT-Handling)
| 1
| icon:check-circle[role=green] DONE

| â€”
| Import Maps fuer Web Components
| 1
| icon:check-circle[role=green] DONE

| â€”
| Web Components: `<bp-workbench>`, `<bp-proof>`, `<bp-admin>`
| 2
| icon:play-circle[role=blue] IN PROGRESS

| â€”
| JWT-Weitergabe als Property an Web Components
| 2
| icon:check-circle[role=green] DONE
|===

<<<
[[phase-3-testdata-details]]
== Phase 3: TestData Management â€” Implementierungsdetails (UC-20, UC-21, TF-8)

*Status:* icon:check-circle[role=green] DONE (2026-02-28)

*Beschreibung:*

Umfassendes TestData-Management-System fÃ¼r Template-Designer zur Verwaltung mehrerer TestdatensÃ¤tze pro Template,
Auto-Generierung von Test-Formularen aus Template-Schemas und PDF-Baseline-Speicherung fÃ¼r Regressionstests.

=== UC-20: Testdaten-Generator aus Template-Feldern

**Auto-Generiertes Formular:**
- Rekursives Tree-Rendering aus `template.validationResult.schema`
- Automatische Input-Typ-Bestimmung (text, number, checkbox basierend auf JSON-Schema-Type)
- Nested Objects und Arrays mit Indentation
- Add/Remove Buttons fÃ¼r Array-Items

**Formulargenerierung:**
- `_renderSchemaProperty()` â€” Hauptrootbau fÃ¼r Schema-Rendering
- `_renderObjectField()` â€” Verschachtelte Objekte
- `_renderArrayField()` â€” Arrays mit +/- Buttons
- `_renderLeafField()` â€” Text-, Number-, Checkbox-Felder
- `_createEmptyItem()` â€” Generiert leere Array-Items mit Defaults

**Default-Testdaten:**
- `_createDefaultTestDataAfterUpload()` â€” Auto-create "default" Datensatz auf Template-Upload
- `_generateDefaultTestData()` â€” Generiert Test-Daten aus Schema-Defaults
- `_generateSampleJsonFromSchema()` â€” Erzeugt Sample-JSON fÃ¼r Preview

=== UC-21: Mehrere Test-Datensaetze pro Template verwalten

**REST-API Endpoints:**
- `GET /api/workbench/templates/{templateId}/testdata` â€” Liste aller TestDataSets
- `POST /api/workbench/templates/{templateId}/testdata` â€” Neuer Testdatensatz erstellen
- `GET /api/workbench/templates/{templateId}/testdata/{testDataSetId}` â€” Einzelner Datensatz abrufen
- `PUT /api/workbench/templates/{templateId}/testdata/{testDataSetId}` â€” Testdatensatz bearbeiten
- `DELETE /api/workbench/templates/{templateId}/testdata/{testDataSetId}` â€” LÃ¶schen

**Frontend UI:**
- Testdaten-List mit Expand/Collapse-Buttons
- TestDataSet-Item mit Name, Meta-Informationen (Expected PDF Status, Erstellungsdatum)
- Tree-View Rendering der Test-Daten
- Bearbeitungs-Modus mit vollstÃ¤ndigem Formular
- Duplikation von Testdaten: `_duplicateTestData()` mit Name-Prompt
- Delete-Buttons mit BestÃ¤tigung

**Features:**
- `_expandedTestDataId` â€” Expand/Collapse State pro Item
- `_editingTestDataId` â€” Edit-Mode Toggle
- `_editingTestDataFormData` â€” Formulardaten wÃ¤hrend Bearbeitung
- Tree-View fÃ¼r Daten-Inspektion
- Duplikations-Funktion: Prompt â†’ Fetch Full Data â†’ Create with Same Data

=== TF-8: PDF-Speicherung als Expected Result

**PDF Speichern:**
- `POST /api/workbench/templates/{templateId}/testdata/{testDataSetId}/save-expected`
- Speichert PDF-BinÃ¤rdaten + SHA256-Hash
- Nur nach erfolgreicher Generierung verfÃ¼gbar

**Frontend:**
- "PDF speichern" Button nach PDF-Generierung
- Trigger: `_saveExpectedPdfForTestData()`
- Flow: PDF generieren â†’ Anzeigen â†’ Speichern-Button klicken
- `_finalizePdfSave()` â€” Finalisiert Speicherung mit Hash

**Backend:**
- TestDataSet Entity: `expectedPdf` (bytea), `pdfHash` (String)
- `testDataSetService.saveExpectedPdf()` â€” Speichert BinÃ¤rdaten
- `testDataSetService.calculateHash()` â€” SHA256 Hash
- `testDataSetService.getExpectedPdf()` â€” Abrufen fÃ¼r Regression-Tests

**Features:**
- Hash fÃ¼r schnelle PDF-Vergleiche
- Storage Service fÃ¼r BinÃ¤rdaten
- Expected PDF Status anzeigen in Liste ("âœ“ Expected PDF" oder "â—‹ Kein Expected PDF")
- Abruf-Endpoint: `GET /api/workbench/templates/{templateId}/testdata/{testDataSetId}/expected-pdf`

=== Implementation Details

**State Management fÃ¼r TestData:**
- `_testDataSets` â€” Liste aller TestdatensÃ¤tze
- `_selectedTestDataForPreview` â€” Aktuell ausgewÃ¤hlter Datensatz
- `_expandedTestDataId` â€” Expanded Item fÃ¼r Tree-View
- `_editingTestDataId` â€” In Bearbeitung befindlicher Datensatz
- `_editingTestDataFormData` â€” Ã„nderungen wÃ¤hrend Bearbeitung
- `_savingTestData` â€” Speichern lÃ¤dt
- `_savingExpectedPdf` â€” PDF speichern lÃ¤dt

**PDF-Preview:**
- Automatische Generierung bei Datensatz-Auswahl
- `_selectTestDataForPreview()` â€” LÃ¤dt Daten und generiert Preview
- Render via blocpress-render API
- `_pdfUrl` â€” Object URL fÃ¼r iframe Display
- Hash-Anzeige neben Preview fÃ¼r Debugging

**Duplication Flow:**
1. User klickt "Duplizieren" auf bestehendem Datensatz
2. Prompt fÃ¼r neuen Namen (default: "Kopie von {original}")
3. Fetch full TestDataSet via GET Endpoint
4. Create new TestDataSet mit gleichen Test-Daten
5. Neue ID zurÃ¼ckgeben, Liste aktualisieren

**Testing:**
- TestDataSet CRUD Operations getestet
- Form-Rendering fÃ¼r komplexe Schemas
- PDF-Speicherung und Hash-Berechnung
- Duplication mit Data Integrity

=== CSS Styling fÃ¼r TestData UI

- `.testdata-list` â€” Container fÃ¼r Liste
- `.testdata-item-container` â€” Wrapper fÃ¼r Item + Expanded Content
- `.testdata-item` â€” Header mit Expand-Button, Name, Meta, Actions
- `.testdata-item-info` â€” Clickable Info Section
- `.testdata-item-actions` â€” Action Buttons (Duplicate, Delete)
- `.testdata-edit-panel` â€” Expanded Edit/View Bereich
- `.testdata-view`, `.testdata-view-header`, `.testdata-tree-view` â€” Read Mode
- `.testdata-edit`, `.testdata-edit-header` â€” Edit Mode
- `.expand-btn` â€” Expand/Collapse Toggle

=== Build Status

âœ“ All TestData operations tested and working
âœ“ PDF generation and storage working
âœ“ Duplication with data integrity verified
âœ“ UI responsive and user-friendly

<<<
[[uc-5-details]]
== UC-5: Template Management Dashboard â€” Implementierungsdetails

*Status:* icon:check-circle[role=green] DONE (2026-02-28)

*Beschreibung:*

VollstÃ¤ndig umgesetztes Template Management Dashboard mit Status-Filtern, Workflow-UnterstÃ¼tzung und
Template-Lifecycle-Management. Ersetzt manuelle Autocomplete-Suche durch visuelle Dashboard-Ansicht.

=== Backend Implementation

**3 neue REST-Endpoints in TemplateResource.java:**

1. *PUT /api/workbench/templates/{id}/status*
   - Ã„ndert Template-Status mit Validierung erlaubter ÃœbergÃ¤nge
   - Transaktional mit StatusUpdateRequest Record
   - Validierung: DRAFTâ†’SUBMITTED, SUBMITTEDâ†’DRAFT/APPROVED/REJECTED, APPROVEDâ†’SUBMITTED, REJECTEDâ†’DRAFT

2. *POST /api/workbench/templates/{id}/duplicate*
   - Erstellt DRAFT-Kopie von existierenden Templates (besonders APPROVED)
   - Name-Konflikt-PrÃ¼fung
   - Re-Validierung der Kopie via TemplateValidator (TF-1)
   - DuplicateRequest Record

3. *PUT /api/workbench/templates/{id}/content*
   - Re-Upload fÃ¼r DRAFT Templates
   - Nur fÃ¼r Status DRAFT erlaubt (BAD_REQUEST sonst)
   - Neu-Validierung und ValidationResult-Update
   - FileUpload via Quarkus @RestForm

**Enhanced Endpoints:**

- GET /api/workbench/templates â€” Jetzt mit `isValid` Flag in TemplateSummary
- TemplateSummary Record erweitert: `boolean isValid` hinzugefÃ¼gt

**Validierungslogik:**

- isValidTransition(TemplateStatus from, TemplateStatus to) â€” Erlaubte ÃœbergÃ¤nge definieren
- Server-seitige Validierung aller Status-Ã„nderungen

=== Frontend Implementation (bp-workbench.js)

**Dashboard-View mit Status-Filtern:**

- `_dashboardView: boolean` â€” Toggle zwischen Dashboard und Workspace
- `_statusFilter: string` â€” Aktiver Filter (ALL, DRAFT, SUBMITTED, APPROVED, REJECTED)
- `_renderDashboard()` â€” Hauptrenderer fÃ¼r Dashboard-Ansicht
- `_renderFilterButtons()` â€” Filter-Bar mit Badge-ZÃ¤hlern
- `_filterTemplates()` â€” Filtern nach Status
- `_countByStatus(status)` â€” ZÃ¤hler pro Status

**Template-Card-System:**

- `_renderTemplateCard(template)` â€” Grid-Card mit Name, Status, Validierung, Aktionen
- Farbcodierte Status-Badges: DRAFT=#888, SUBMITTED=#1976d2, APPROVED=#388e3c, REJECTED=#d32f2f
- `_getStatusColor(status)` â€” Farb-Mapping
- `_getStatusIcon(status)` â€” Emoji-Icons (ðŸ“, ðŸ§ª, âœ…, âŒ)

**Status-spezifische Aktionen:**

- `_getTemplateActions(template)` â€” Action-Buttons basierend auf Status
- DRAFT: Ã–ffnen, Aktualisieren, â†’ Test, LÃ¶schen
- SUBMITTED: Ã–ffnen, â† ZurÃ¼ck, âœ“ Genehmigen, âœ— Ablehnen
- APPROVED: Ã–ffnen, â† ZurÃ¼ck zu Test, Als Kopie
- REJECTED: Ã–ffnen, â† ZurÃ¼ck, LÃ¶schen

**Workflow-Handler:**

- `_changeStatus(templateId, newStatus)` â€” Status via PUT Endpoint Ã¤ndern
- `_duplicateTemplate(template)` â€” Prompt fÃ¼r Name, dann POST /duplicate
- `_updateTemplate(template)` â€” File-Dialog, dann PUT /content
- `_deleteTemplate(templateId)` â€” Confirmation, dann DELETE
- `_openTemplate(template)` â€” Dashboard â†’ Workspace wechsel
- `_returnToDashboard()` â€” Workspace â†’ Dashboard zurÃ¼ck

**CSS-Styling (200+ Zeilen):**

- `.dashboard` â€” Container
- `.dashboard-header` â€” Titel + Upload-Button
- `.filter-buttons` â€” Filter-Bar mit Active-State
- `.filter-btn`, `.filter-btn.active` â€” Filter Button Styling
- `.template-list` â€” Grid-Layout (340px min, auto-fill)
- `.template-card` â€” Card mit Shadow, Hover, Flex-Layout
- `.card-header`, `.card-meta`, `.card-actions` â€” Card Sections
- `.status-badge-card` â€” Farbige Status-Badges
- `.action-btn` â€” Action Buttons mit Varianten (.primary, .success, .danger, .secondary)
- `.empty-state` â€” Keine Templates Message
- `.workspace-header` â€” Back-Button + Title
- `.btn-primary`, `.btn-back` â€” PrimÃ¤r- und Back-Button Styling

=== State Management

- `_dashboardView` â€” true=Dashboard, false=Workspace
- `_statusFilter` â€” Aktiver Filter (default: 'ALL')
- Auto-Refresh der Template-Liste nach Status-Ã„nderungen
- Filter bleibt aktiv wÃ¤hrend Refresh

=== Error Handling

- Server-seitige Validierung aller ÃœbergÃ¤nge
- Name-Konflikt-PrÃ¼fung (409 CONFLICT)
- Re-Upload nur fÃ¼r DRAFT (BAD_REQUEST sonst)
- Client zeigt Error/Success Messages via _error/_success

=== Testing & Quality Assurance

**Unit Tests (TemplateResourceUnitTest.java):**
- 16 Tests fÃ¼r TemplateSummary (mit neues isValid field)
- 49 Tests insgesamt im Module
- Alle 9 Test-Methoden aktualisiert fÃ¼r neues Feld
- 0 Failures, 0 Errors, 0 Skipped

**Coverage:**
- JaCoCo enforces 70% instruction coverage
- Alle neuen API Endpoints abgedeckt

**Build Status:**
- âœ“ mvn clean verify -DskipITs: SUCCESS
- âœ“ 49 tests executed, 0 failures
- âœ“ Code coverage maintained > 70%

=== Documentation Updates

1. **arc42.adoc** â€” New Runtime Scenario "Template Management Dashboard (UC-5)"
2. **System_Design_Concept.adoc** â€” New System Scenario + enhanced blocpress-workbench description
3. **Solution_Design_Concept.adoc** â€” Business Process "Template erstellen und freigabe" updated
4. **Element_Design_Concept.adoc** â€” TI-1 REST Endpoints, UI-1 Dashboard Description
5. **product-backlog.adoc** â€” UC-5 marked as DONE

=== Git Commits

- `cf05c10` â€” feat: Implement Template Management Dashboard with Status-Filter & Workflow (UC-5)
- `a5c5040` â€” docs: Update specifications with UC-5 Dashboard & Workflow functionality

=== Files Modified

**Backend (2 files):**
- `TemplateResource.java` â€” 3 neue Endpoints + Validierungslogik
- `TemplateResourceUnitTest.java` â€” 9 Tests aktualisiert fÃ¼r isValid Field

**Frontend (1 file):**
- `bp-workbench.js` â€” Dashboard View + 1300+ neue Zeilen Code/CSS

**Documentation (5 files):**
- `product-backlog.adoc`, `arc42.adoc`, `System_Design_Concept.adoc`, `Solution_Design_Concept.adoc`, `Element_Design_Concept.adoc`

=== AbhÃ¤ngigkeiten fÃ¼r zukÃ¼nftige Features

**FÃ¼r Epic 4 (PrÃ¼fung und Freigabe):**
- UC-5 Status-Filter wird genutzt, um eingereichte Templates zu filtern
- Vier-Augen-Prinzip (TF-2) wird auf Status-ÃœbergÃ¤nge erweitert
- User-Management (E-9) kann hinzugefÃ¼gt werden, um creator_id/approver_id zu tracken

**FÃ¼r Roadmap:**
- Re-Upload (PUT /content) ist Basis fÃ¼r Template-Versionierung
- Dashboard UI wird Basis fÃ¼r weitere Admin-Features
- Status-Filter Pattern kann fÃ¼r andere Entities (Bausteine, Reviews) wiedergenutz werden

<<<
[[uc-10-details]]
== UC-10: Template-ID-basiertes Rendering â€” Implementierungsdetails

*Status:* icon:check-circle[role=green] DONE (2026-02-28)

*Beschreibung:*

Production-ready Template-Rendering mit Template-IDs statt Binary-Upload. ErmÃ¶glicht wiederholtes
Rendering derselben Templates mit verschiedenen DatensÃ¤tzen ohne erneuten Upload. Nur genehmigte
Templates (APPROVED-Status) sind zugÃ¤nglich. ZwischenlÃ¶sung fÃ¼r cross-module HTTP-Kommunikation
bis TI-2 (Multi-Schema-Setup) implementiert ist.

=== Architektur-Entscheidung

**Interim-LÃ¶sung (UC-10):**
- blocpress-render ruft blocpress-workbench per REST API ab
- Nur APPROVED Templates sind zugÃ¤nglich
- Template-Content in-memory cached (Caffeine, 10 min TTL, max 100 Templates)
- Keine Multi-Schema-Datenbank (wird TI-2 sein)

**ZukÃ¼nftige Refaktorierung (TI-2):**
- blocpress-render liest direkt aus `production`-Schema
- Keine Cross-Module HTTP-Calls mehr
- Template-Promotion: workbench â†’ production Schema
- Public API bleibt unverÃ¤ndert

=== Backend Implementation (blocpress-workbench)

**Neuer Endpoint in TemplateResource.java:**

```
GET /api/workbench/templates/{id}/content
```

- Parameter: `id` (UUID)
- Response: 200 OK mit ODT-Binary fÃ¼r APPROVED Templates
- Response Headers: `Content-Disposition`, `X-Template-Name`, `X-Template-Status`
- Error 403 Forbidden: Template nicht APPROVED (DRAFT/SUBMITTED/REJECTED)
- Error 404 Not Found: Template existiert nicht
- Security: Nur APPROVED Templates sind zugÃ¤nglich

=== Backend Implementation (blocpress-render)

**Neue Klassen:**

1. *TemplateCache.java* â€” Quarkus Cache Service
   - `@CacheResult` mit Caffeine Caching
   - HTTP-Client zu blocpress-workbench
   - TTL: 10 Minuten, Max Size: 100 Templates
   - Wirft `TemplateNotFoundException` fÃ¼r 403/404

2. *TemplateNotFoundException.java* â€” Custom Exception
   - Unterscheidung: "not found" (404) vs. "not approved" (403)

**Neuer OpenAPI Endpoint:**

```
POST /api/render/{id}
```

- Path Parameter: `id` (UUID)
- Request Body: `RenderByIdRequest` (data + outputType)
- Response: 200 OK mit Binary Document (PDF/RTF/ODT)
- Error 404 Not Found: Template ID existiert nicht
- Error 403 Forbidden: Template nicht APPROVED
- Error 500 Internal Server Error: Rendering Error

**RenderByIdRequest Schema:**

```json
{
  "data": { "customer.name": "...", ... },
  "outputType": "pdf|rtf|odt"
}
```

=== Konfiguration & Dependencies

**pom.xml (blocpress-render):**
```xml
<dependency>
  <groupId>io.quarkus</groupId>
  <artifactId>quarkus-cache</artifactId>
</dependency>
```

**application.properties (blocpress-render):**
```properties
quarkus.cache.enabled=true
quarkus.cache.type=caffeine
quarkus.cache.caffeine."templates".maximum-size=100
quarkus.cache.caffeine."templates".expire-after-write=10M
blocpress.workbench.url=http://localhost:8081
```

=== Caching-Verhalten

**Erste Anfrage (Cache Miss):**
1. Client ruft `POST /api/template/{id}/render` auf
2. RenderResource.renderDocumentById() wird aufgerufen
3. TemplateCache.getTemplateContent(id) wird aufgerufen
4. HTTP GET zu blocpress-workbench wird ausgefÃ¼hrt
5. Template-Content wird in Cache gespeichert
6. Rendering mit gecachtem Template

**Nachfolgende Anfragen (Cache Hit):**
1. Gleicher Prozess bis Schritt 3
2. Cached Template wird direkt zurÃ¼ckgegeben (kein HTTP-Call)
3. Schnelleres Rendering

**Cache-Invalidation:**
- Nach 10 Minuten automatisch invalidiert
- Template-Updates in blocpress-workbench sind nach max. 10 min sichtbar
- Keine manuellen Cache-Invalidierung notwendig

=== Testing

**Unit Tests (blocpress-workbench):**
- `getTemplateContent_approvedTemplate_returnsContent()` â€” 200 OK
- `getTemplateContent_draftTemplate_returns403()` â€” 403 Forbidden
- `getTemplateContent_nonExistent_returns404()` â€” 404 Not Found

**Integration Tests (blocpress-render):**
- `renderDocumentById_withValidTemplate_generatesDocument()` â€” 200 OK
- `renderDocumentById_withNonExistentTemplate_returns404()` â€” 404 Not Found
- Cache-Verifikation durch Log-Analyse

**Test-Setup:**
- Requires: blocpress-workbench auf localhost:8081 oder WireMock Mock
- Templates: Nutzung bestehender Kuendigung-Templates aus blocpress-core
- Assertions: PDF-Generierung, Response-Status, Header-Validierung

=== REST API Usage Example

**Request:**

```bash
curl -X POST http://localhost:8080/api/render/{template-id} \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer eyJhbGc..." \
  -d '{
    "data": {
      "customer.name": "ACME Corp",
      "invoice.number": "INV-2024-001"
    },
    "outputType": "pdf"
  }'
```

**Response (200 OK):**

```
HTTP/1.1 200 OK
Content-Type: application/pdf
Content-Disposition: attachment; filename="generated-document.pdf"

<binary PDF content>
```

**Error Response (404 Not Found):**

```json
{
  "error": "Template not found: 12345678-1234-1234-1234-123456789012"
}
```

**Error Response (403 Forbidden):**

```json
{
  "error": "Template not approved: 12345678-1234-1234-1234-123456789012"
}
```

=== Documentation Updates

1. **arc42.adoc** â€” New Runtime Scenario "Template-ID-basiertes Rendering (UC-10)"
   - PlantUML Sequenzdiagramm mit Cache-Hit/Miss-Szenarien
   - Architecture Decision Record (ADR): Interim HTTP-Solution

2. **Element_Design_Concept.adoc** â€” TI-1.3 REST Endpoints
   - `POST /api/template/{id}/render` Endpoint-Dokumentation
   - `GET /api/workbench/templates/{id}/content` Internal API Endpoint

3. **product-backlog.adoc** â€” UC-10 marked DONE
   - Implementation Details dokumentiert
   - Refactoring Path zu TI-2 klar definiert

=== Files Modified

**Backend (2 modules):**
- `blocpress-workbench/src/main/java/.../TemplateResource.java` â€” getTemplateContent() Endpoint
- `blocpress-render/src/main/java/.../RenderResource.java` â€” renderDocumentById() Implementierung
- `blocpress-render/src/main/java/.../TemplateCache.java` (NEW) â€” Cache Service
- `blocpress-render/src/main/java/.../TemplateNotFoundException.java` (NEW) â€” Exception
- `blocpress-render/pom.xml` â€” quarkus-cache Dependency
- `blocpress-render/src/main/resources/application.properties` â€” Cache Config

**OpenAPI:**
- `blocpress-render/src/main/resources/META-INF/openapi.yml` â€” New Endpoint Spec

**Testing:**
- `blocpress-workbench/src/test/.../TemplateResourceUnitTest.java` â€” Tests fÃ¼r neuen Endpoint
- `blocpress-render/src/test/.../TemplateResourceTest.java` â€” Integration Test Documentation

**Documentation:**
- `docs/product-backlog.adoc`, `docs/specification/arc42.adoc`, `docs/specification/Element_Design_Concept.adoc`

=== Future Migration Path (TI-2)

**Ã„nderungen wenn TI-2 implementiert:**

1. `TemplateCache.java` entfernen
2. `TemplateNotFoundException.java` ggf. unverÃ¤ndert lassen
3. Neue Klasse: `TemplateRepository` mit direct DB access
4. application.properties: `blocpress.workbench.url` entfernen
5. pom.xml: ZusÃ¤tzliche DB-Dependencies fÃ¼r `production`-Schema
6. RenderResource.renderDocumentById(): HTTP-Call ersetzen durch DB-Query
7. Arc42: Sequenzdiagramm anpassen (keine HTTP-Calls mehr)
8. Product Backlog: TI-2 story mit Refactoring-Details

**Public API bleibt unverÃ¤ndert:**
- `POST /api/template/{id}/render` â€” Interface unchanged
- Request/Response Format â€” Gleich
- Error Codes â€” Gleich

=== Build Status

âœ“ All UC-10 code implemented and integrated
âœ“ OpenAPI schema updated with new endpoint
âœ“ Cache configuration added to properties
âœ“ Tests added for endpoint behavior documentation
âœ“ All dependencies resolved (quarkus-cache)
âœ“ Integration with existing rendering pipeline

<<<
== Abhaengigkeiten

[plantuml, backlog-dependencies, svg]
----
@startuml
skinparam componentStyle rectangle

component "Epic 1\nRendering Engine\n(teilweise DONE)" as E1 #lightgreen
component "Epic 2\nStorage & Persistence" as E2
component "Epic 3\nWorkbench" as E3
component "Epic 4\nProof & Freigabe" as E4
component "Epic 5\nAdministration" as E5
component "Epic 6\nPortal & Frontends" as E6

E1 <-- E2 : benoetigt DB\nfuer Template-ID
E2 <-- E3 : benoetigt Schemas\n& StorageService
E2 <-- E4 : benoetigt Schemas\n& StorageService
E2 <-- E5 : benoetigt Schema admin
E3 <-- E4 : liefert Templates\nzur Pruefung
E3 <-- E6 : Web Component\nbp-workbench
E4 <-- E6 : Web Component\nbp-proof
E5 <-- E6 : Web Component\nbp-admin
@enduml
----

*Reihenfolge:*

. *Epic 6* (Studio) -- Minimale Portal-Shell als Einstiegspunkt (Navigation, JWT)
. *Epic 3* (Workbench) -- Erster fachlicher Anwendungsfall fuer Template-Designer (UC-1: Upload)
. *Epic 1* (Rendering Engine) -- Offene Punkte (Template-ID-Rendering, Caching) nach Bedarf
. *Epic 4* (Proof & Freigabe) -- Aufbauend auf Workbench
. *Epic 5* (Administration) -- RBAC und Audit-Logging
. _Epic 2 (Storage & Persistence) entsteht inkrementell beim Aufbau der Epics 3, 4, 5_