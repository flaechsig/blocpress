ifndef::imagesdir[:imagesdir: ../images]

image:blocpress-logo-large.png[]

= System Design Concept

[[sydc-goals]]
== Goals

Das technische System blocpress soll folgende Ziele im Rahmen der digitalen L√∂sung erreichen:

*Automatisierte Dokumentengenerierung:* Das System soll LibreOffice-Templates mit JSON-Daten zusammenf√ºhren und automatisiert professionelle Dokumente (ODT, PDF, RTF) generieren. Die Generierung erfolgt deterministisch und performant √ºber eine REST-API. +
_Fachliche Grundlage: xref:Solution_Design_Concept.adoc#sdc-vision[Vision im Solution Design Concept]_

*Zentrale Template-Verwaltung:* Das System soll Templates und Bausteine zentral speichern, versionieren und f√ºr autorisierte Nutzer bereitstellen. √Ñnderungen an Templates m√ºssen nachvollziehbar sein und der aktuelle Freigabestatus jederzeit erkennbar. +
_Fachliche Grundlage: xref:Solution_Design_Concept.adoc#sdc-ia[Information Architecture im Solution Design Concept]_

*Workflow-gesteuerte Qualit√§tssicherung:* Das System soll einen mehrstufigen Freigabeprozess mit Rollen und Berechtigungen implementieren, sodass Templates nur nach erfolgreicher Pr√ºfung in der Produktion verwendet werden k√∂nnen. +
_Gesch√§ftsprozess: xref:Solution_Design_Concept.adoc#sdc-bp-erstellen[Template erstellen und freigeben]_

*Compliance-Unterst√ºtzung:* Das System soll turnusm√§√üige Reviews automatisch planen, √ºberwachen und durchsetzen. Templates mit abgelaufenen Review-Fristen m√ºssen gekennzeichnet und zur Pr√ºfung vorgelegt werden. +
_Gesch√§ftsprozess: xref:Solution_Design_Concept.adoc#sdc-bp-review[Turnusm√§√üiges Compliance Review]_

*Umfassende Testunterst√ºtzung:* Das System soll Testdaten verwalten, Abnahme-PDFs generieren und Regressionstests automatisiert ausf√ºhren. Abweichungen von erwarteten Ergebnissen m√ºssen erkannt und gemeldet werden. +
_Gesch√§ftsprozess: xref:Solution_Design_Concept.adoc#sdc-bp-testen[Template testen und Regressionstests]_

*Intelligente Inhaltssuche:* Das System soll alle Templates und Bausteine indexieren und eine performante Volltextsuche nach fachlichen Konstrukten erm√∂glichen, um Konsistenz √ºber alle Dokumente hinweg zu gew√§hrleisten. +
_Gesch√§ftsprozess: xref:Solution_Design_Concept.adoc#sdc-bp-suche[Fachliche Konstrukte recherchieren]_

*Skalierbare Container-Architektur:* Das System soll als Docker-Container betrieben werden k√∂nnen und gleichzeitige Anfragen mehrerer Anwendungen effizient verarbeiten.

[[sydc-architecture]]
== System Architecture

Die Systemarchitektur von blocpress besteht aus folgenden Elementen:

[[sydc-users]]
=== User Types

*Template-Designer:* Nutzt blocpress-workbench (via blocpress-studio) zum Hochladen, Bearbeiten und Verwalten von Templates und Bausteinen. Arbeitet prim√§r in LibreOffice und l√§dt fertige Templates hoch.

*Pr√ºfer (QM / Freigeber / Compliance):* Konsolidierte Rolle, die blocpress-proof (via blocpress-studio) nutzt. Pr√ºft Templates, gibt frei oder lehnt ab, f√ºhrt Compliance-Reviews durch, verwaltet Testdaten und f√ºhrt Regressionstests aus.

*Administrator:* Nutzt blocpress-admin (via blocpress-studio) zur Verwaltung von Benutzerkonten, Rollen, Berechtigungen und System-Konfiguration.

*API-Konsument (Entwickler):* Nutzt die √∂ffentliche REST-API von blocpress-render zur programmatischen Dokumentengenerierung aus Anwendungssystemen heraus.

_Fachliche Kundensegmente: xref:Solution_Design_Concept.adoc#sdc-vp[Value Proposition im Solution Design Concept]_

[[sydc-software]]
=== Software Elements

Die Anwendung ist als Self-Contained Systems (SCS) strukturiert ‚Äî f√ºnf unabh√§ngig deploybare Module mit eigener UI, eigenem Backend und eigenem Datenbank-Schema:

*blocpress-studio (Portal-Shell):* Quarkus-Anwendung, die statische HTML/JS-Assets ausliefert. Verantwortlich f√ºr Navigation, JWT-Authentifizierung und Integration der Micro-Frontends via Dynamic Import. Kein eigenes Backend-Logik. L√§dt die Web Components der fachlichen Module dynamisch von den jeweiligen SCS-Modulen.

*blocpress-workbench (Quarkus):* Template-Entwicklung ‚Äî Upload, Validierung (TF-1 via blocpress-core), Bearbeitung, Bausteinverwaltung, Content Search (Elasticsearch), Vorschau-Generierung, **Template Management Dashboard mit Status-Filtern und Workflow** (UC-5: Status-√úberg√§nge, Duplikation, Re-Upload). Arbeitsumgebung f√ºr Template-Designer. Nutzt Schema `workbench`. +
_Use Cases: UC-1 bis UC-5, UC-19 bis UC-21_ +
_Detaillierte Beschreibung: xref:Element_Design_Concept.adoc#edc-goals[Goals im Element Design Concept]_

*blocpress-proof (Quarkus):* Pr√ºfung und Freigabe ‚Äî Workflow (TF-2, Vier-Augen-Prinzip), Testdaten, Regressionstests (TF-6), Compliance-Reviews (TF-7), Stufen√ºbergabe nach production. Arbeitsumgebung f√ºr Pr√ºfer. Nutzt Schema `proof`. +
_Use Cases: UC-6 bis UC-9, UC-11 bis UC-18_ +
_Technical Functions: xref:Element_Design_Concept.adoc#edc-tf-2[TF-2], xref:Element_Design_Concept.adoc#edc-tf-6[TF-6], xref:Element_Design_Concept.adoc#edc-tf-7[TF-7]_

*blocpress-render (Quarkus):* Dokumentengenerierung ‚Äî einzige √∂ffentliche REST-API. Liest freigegebene Templates aus Schema `production`. Nutzt blocpress-core (Merge-Pipeline) und LibreOffice headless (Format-Export, Version ‚â• 24). Stateless, horizontal skalierbar. +
_Technical Function: xref:Element_Design_Concept.adoc#edc-tf-5[TF-5: Dokument generieren]_

*blocpress-admin (Quarkus):* Administration ‚Äî Benutzerverwaltung, Rollenzuweisung, Systemkonfiguration, Audit-Logs. Nutzt Schema `admin`. +
_Use Cases: UC-22 bis UC-24_

*Shared Library:*

*blocpress-core:* Gemeinsame Java-Library (Maven-Abh√§ngigkeit, kein eigenst√§ndiger Container). Enth√§lt ODT-Parsing (odfdom), Template-Validierung und Merge-Pipeline (Text-Block-Expansion, Bedingungsauswertung, Schleifenbehandlung, Feldersetzung). Keine LibreOffice-Abh√§ngigkeit. Wird von blocpress-workbench (TF-1: Validierung) und blocpress-render (TF-5: Merge-Schritt) genutzt.

*Gemeinsame Infrastruktur:*

*PostgreSQL-Datenbank (Version ‚â• 18):* Eine Datenbankinstanz mit vier getrennten Schemata (`workbench`, `proof`, `production`, `admin`). Template-Tabellen haben in workbench/proof/production identische Struktur f√ºr kopie-basierte Stufen√ºbergabe. Bin√§rdaten als bytea (< 5.000 Dokumente). Storage Abstraction Layer f√ºr zuk√ºnftigen S3-Wechsel. +
_Technical Interface: xref:Element_Design_Concept.adoc#edc-ti-2[TI-2: Datenbank-Interface]_ +
_Entities: xref:Element_Design_Concept.adoc#edc-entities[Entities im Element Design Concept]_

*Content Search Engine (Elasticsearch ‚â• 7.x):* Suchindex f√ºr Templates und Bausteine, genutzt von blocpress-workbench. +
_Technical Interface: xref:Element_Design_Concept.adoc#edc-ti-7[TI-7: Elasticsearch API]_

*Message Queue (RabbitMQ/Kafka):* Asynchrone Dokumentengenerierung und Regressionstests. +
_Technical Interface: xref:Element_Design_Concept.adoc#edc-ti-5[TI-5: Message Queue Interface]_

[[sydc-hardware]]
=== Hardware Elements

*Container Platform:* Docker-Host oder Kubernetes-Cluster zum Betrieb aller SCS-Container (studio, workbench, proof, render, admin). Mindestens 16 GB RAM und 4 CPU-Cores f√ºr produktive Umgebung.

*Datenbank-Server:* Dedizierter Server oder Container f√ºr PostgreSQL (Version ‚â• 18) mit persistentem Storage. Eine Instanz mit vier Schemata (workbench, proof, production, admin). Mindestens 8 GB RAM, 100 GB SSD-Storage.

*Load Balancer:* Hardware- oder Software-Load-Balancer zur Verteilung von Last auf mehrere blocpress-render-Instanzen (horizontal skalierbar f√ºr Dokumentengenerierung).

*Client-Ger√§te:* Desktop-Computer oder Laptops f√ºr Template-Designer, Pr√ºfer und Administratoren mit modernem Webbrowser (Chrome, Firefox, Edge) und LibreOffice-Installation.

[[sydc-partner]]
=== Partner Elements

*JWT-basierte Authentifizierung:* blocpress-studio √ºbernimmt die Authentifizierung und reicht das JWT als Property an die Web Components weiter. Jedes SCS-Modul validiert JWTs eigenst√§ndig via Quarkus SmallRye JWT. Es besteht keine Laufzeitabh√§ngigkeit zu einem externen Identity Provider. +
_Technical Interface: xref:Element_Design_Concept.adoc#edc-ti-4[TI-4: JWT-Validierung]_

*Observability (optional):* Alle SCS-Module exportieren Traces, Metriken und Logs √ºber OpenTelemetry (OTLP-Protokoll). Der Betreiber kann einen beliebigen OTLP-kompatiblen Collector einsetzen (z.B. Grafana Alloy, Jaeger, Datadog Agent). Ohne konfiguriertem Endpoint laufen die Module ohne externe Monitoring-Abh√§ngigkeit.

*Backup-System:* Bestehendes Backup-System der Organisation zur regelm√§√üigen Sicherung der PostgreSQL-Datenbank (inkl. Bin√§rdaten).

[[sydc-scenarios]]
== System Scenarios

[[sydc-scenario-upload]]
=== Szenario: Template hochladen und zur Freigabe einreichen

*Ziel:* Ein Template-Designer erstellt ein neues Template und reicht es zur Qualit√§tspr√ºfung ein.

1. Der Template-Designer meldet sich √ºber blocpress-studio an (Authentifizierung erfolgt √ºber JWT)
2. blocpress-studio l√§dt das Web Component `<bp-workbench>` und reicht das JWT als Property weiter
3. Der Template-Designer l√§dt eine LibreOffice-Datei (.odt) √ºber die Workbench-Oberfl√§che hoch
4. Das Web Component sendet die Datei an blocpress-workbench √ºber die interne REST-API
5. blocpress-workbench speichert die Datei im Schema `workbench` (PostgreSQL) und erstellt einen Metadaten-Eintrag
6. blocpress-workbench validiert die Template-Datei √ºber blocpress-core (ODT-Parsing ohne LibreOffice)
7. blocpress-core analysiert User-Fields, Wiederholungsgruppen und IF-Bedingungen und meldet Ergebnisse zur√ºck
8. blocpress-workbench speichert die Validierungsergebnisse und aktualisiert den Template-Status auf "Entwurf"
9. Der Template-Designer sieht die Validierungsergebnisse und reicht das Template zur Pr√ºfung ein
10. blocpress-workbench kopiert das Template in das Schema `proof` (Stufen√ºbergabe workbench ‚Üí proof)
11. Das Template ist nun in blocpress-proof f√ºr den Pr√ºfer sichtbar

_Use Cases: xref:Element_Design_Concept.adoc#edc-uc-1[UC-1: Template hochladen], xref:Element_Design_Concept.adoc#edc-uc-2[UC-2: Zur Freigabe einreichen], xref:Element_Design_Concept.adoc#edc-uc-5[UC-5: Template Management Dashboard mit Workflow]_ +
_Gesch√§ftsprozess: xref:Solution_Design_Concept.adoc#sdc-bp-erstellen[Template erstellen und freigeben]_

[[sydc-scenario-dashboard]]
=== Szenario: Template-Management-Dashboard mit Status-Filter und Workflow (UC-5)

*Ziel:* Ein Template-Designer verwaltet seine Templates √ºber ein visuelles Dashboard mit Status-Filtern und f√ºhrt Workflow-√úberg√§nge durch.

1. Der Template-Designer meldet sich √ºber blocpress-studio an
2. blocpress-studio l√§dt das Web Component `<bp-workbench>` und reicht das JWT als Property weiter
3. Der Template-Designer √∂ffnet blocpress-workbench und sieht das Template Management Dashboard (statt Autocomplete-Suche)
4. Das Dashboard zeigt alle Templates als Karten in Gitteransicht mit Status-Badges (DRAFT, SUBMITTED, APPROVED, REJECTED)
5. Der Template-Designer filtert Templates nach Status (z.B. "üß™ Test" zeigt nur SUBMITTED-Templates)
6. F√ºr DRAFT-Templates sieht der Designer Aktionen: √ñffnen, Aktualisieren, ‚Üí Test, L√∂schen
7. Der Designer klickt "‚Üí Test" um ein DRAFT-Template zur Freigabe einzureichen (Status √§ndert sich zu SUBMITTED)
8. blocpress-workbench validiert die Status√ºbergangs-Logik und speichert den neuen Status
9. F√ºr APPROVED-Templates sieht der Designer "Als Kopie" Button
10. Der Designer klickt "Als Kopie", gibt einen Namen ein, und ein neues DRAFT-Template wird erstellt (Basis f√ºr neue Entwicklung)
11. F√ºr DRAFT-Templates sieht der Designer "Aktualisieren" Button zum Re-Upload einer aktualisierten ODT-Datei
12. Das Template wird neu validiert und die Validierungsergebnisse aktualisiert
13. Der Designer klickt auf ein Template-Card "√ñffnen" um den Workspace mit Testdaten und Vorschau zu √∂ffnen
14. Der Designer kann √ºber "‚Üê Zur√ºck zum Dashboard" zur√ºck zur √úbersicht gehen

_Use Case: xref:Element_Design_Concept.adoc#edc-uc-5[UC-5: Template Management Dashboard mit Status-Filtern und Workflow]_ +
_Technical Functions: Status-√úberg√§nge mit Validierung (von TF-2), Template-Duplikation, Re-Upload (TF-1 Neu-Validierung)_

[[sydc-scenario-generate]]
=== Szenario: Dokument √ºber API generieren

*Ziel:* Eine externe Anwendung generiert ein Dokument basierend auf einem freigegebenen Template.

1. Die externe Anwendung sendet einen POST-Request mit Template-ID und JSON-Daten an blocpress-render (einzige √∂ffentliche API)
2. blocpress-render authentifiziert die Anfrage (JWT-Validierung)
3. blocpress-render validiert die JSON-Daten gegen das Template-Schema
4. blocpress-render l√§dt das freigegebene Template aus dem Schema `production` (PostgreSQL)
5. blocpress-render legt die Generierungsanfrage in die Message Queue f√ºr asynchrone Verarbeitung
6. Der LibreOffice Document Processor nimmt die Anfrage aus der Queue entgegen
7. Der Document Processor bef√ºllt das Template mit den JSON-Daten (User-Fields, Wiederholungsgruppen, IF-Bedingungen)
8. Der Document Processor exportiert das bef√ºllte Dokument im gew√ºnschten Format (ODT, PDF oder RTF)
9. Das generierte Dokument wird im Schema `production` gespeichert
10. blocpress-render aktualisiert den Generierungs-Status auf "Erfolgreich"
11. Die externe Anwendung erh√§lt die Generierungs-ID als Response und kann den Status abfragen
12. Beim Status-Abruf liefert blocpress-render einen Download-Link f√ºr das generierte Dokument zur√ºck

_Technical Function: xref:Element_Design_Concept.adoc#edc-tf-5[TF-5: Dokument generieren]_ +
_Use Case: xref:Element_Design_Concept.adoc#edc-uc-10[UC-10: Testdokument mit Template generieren]_ +
_Gesch√§ftsprozess: xref:Solution_Design_Concept.adoc#sdc-bp-generieren[Dokument automatisiert generieren]_

[[sydc-scenario-regression]]
=== Szenario: Automatischer Regressionstest nach Template-√Ñnderung

*Ziel:* Nach einer Template-√Ñnderung werden automatisch alle zugeh√∂rigen Regressionstests ausgef√ºhrt.

1. Ein Template wird von blocpress-workbench an blocpress-proof √ºbergeben (Stufen√ºbergabe workbench ‚Üí proof)
2. blocpress-proof empf√§ngt das Template im Schema `proof` und triggert das Test Framework
3. Das Test Framework (in blocpress-proof) ermittelt alle Test Cases, die dem Template zugeordnet sind
4. F√ºr jeden Test Case l√§dt das Test Framework die gespeicherten JSON-Testdaten aus dem Schema `proof`
5. Das Test Framework sendet Generierungsanfragen an blocpress-render √ºber die interne REST-API
6. blocpress-render generiert PDFs f√ºr alle Test Cases
7. Das Test Framework l√§dt die generierten PDFs und die gespeicherten Baseline-PDFs
8. Das Test Framework vergleicht die PDFs pixel- oder textbasiert
9. Abweichungen werden dokumentiert und im Schema `proof` gespeichert
10. Der Pr√ºfer √∂ffnet blocpress-proof (via blocpress-studio) und sieht die Test-Ergebnisse
11. Der Pr√ºfer entscheidet, ob Abweichungen akzeptabel sind oder das Template √ºberarbeitet werden muss

_Technical Functions: xref:Element_Design_Concept.adoc#edc-tf-5[TF-5: Dokument generieren], xref:Element_Design_Concept.adoc#edc-tf-6[TF-6: PDF vergleichen]_ +
_Use Case: xref:Element_Design_Concept.adoc#edc-uc-16[UC-16: Test ausf√ºhren]_ +
_Gesch√§ftsprozess: xref:Solution_Design_Concept.adoc#sdc-bp-testen[Template testen und Regressionstests]_

[[sydc-scenario-compliance]]
=== Szenario: Turnusm√§√üiges Compliance Review durchf√ºhren

*Ziel:* Der Compliance Manager erkennt ein f√§lliges Review und benachrichtigt den zust√§ndigen Reviewer.

1. Der Compliance Manager (in blocpress-proof) l√§uft als geplanter Job und pr√ºft t√§glich alle freigegebenen Templates im Schema `proof`
2. F√ºr jedes Template berechnet der Compliance Manager das n√§chste Review-Datum basierend auf dem Review-Zyklus (1, 3 oder 5 Jahre)
3. Der Compliance Manager identifiziert Templates, deren Review-Datum in den n√§chsten 30 Tagen liegt oder bereits √ºberschritten ist
4. F√ºr jedes f√§llige Template erstellt der Compliance Manager einen Review-Eintrag im Schema `proof` mit Status "Anstehend"
5. Der Pr√ºfer meldet sich √ºber blocpress-studio an und sieht f√§llige Reviews in blocpress-proof
6. Der Pr√ºfer √∂ffnet ein Template zur Pr√ºfung und vergleicht es mit aktuellen rechtlichen und fachlichen Anforderungen
7. Der Pr√ºfer hinterl√§sst Kommentare und markiert das Template als "Freigegeben" oder "√úberarbeitung erforderlich"
8. blocpress-proof aktualisiert den Review-Status und berechnet das n√§chste Review-Datum
9. Bei "√úberarbeitung erforderlich" wird das Template in blocpress-workbench als "√úberarbeitung erforderlich" markiert

_Technical Function: xref:Element_Design_Concept.adoc#edc-tf-7[TF-7: Compliance-Reviews √ºberpr√ºfen]_ +
_Use Case: xref:Element_Design_Concept.adoc#edc-uc-12[UC-12: Review durchf√ºhren]_ +
_Gesch√§ftsprozess: xref:Solution_Design_Concept.adoc#sdc-bp-review[Turnusm√§√üiges Compliance Review]_

[[sydc-scenario-search]]
=== Szenario: Fachliche Konstrukte √ºber alle Templates suchen

*Ziel:* Ein Template-Designer sucht nach einem fachlichen Konstrukt, um zu pr√ºfen, in welchen Dokumenten es verwendet wird.

1. Der Template-Designer meldet sich √ºber blocpress-studio an
2. Der Template-Designer gibt den Suchbegriff "Beitragsanpassung" in das Suchfeld der Workbench-Oberfl√§che ein
3. Das Web Component sendet eine Such-Anfrage an blocpress-workbench √ºber die interne REST-API
4. blocpress-workbench leitet die Anfrage an die Content Search Engine (Elasticsearch) weiter
5. Die Content Search Engine durchsucht den Index nach dem Begriff in allen Templates und Bausteinen
6. Die Search Engine liefert eine Liste von Treffern mit Template-ID, Baustein-ID, Kontext und Position zur√ºck
7. blocpress-workbench reichert die Suchergebnisse mit Metadaten (Template-Name, Status, Version) aus dem Schema `workbench` an
8. Die Workbench-Oberfl√§che zeigt die Suchergebnisse gruppiert nach Templates und Bausteinen an
9. Der Template-Designer w√§hlt einen Treffer aus
10. Die Workbench-Oberfl√§che √∂ffnet das entsprechende Template oder den Baustein und markiert die gefundene Stelle

_Use Case: xref:Element_Design_Concept.adoc#edc-uc-19[UC-19: Nach Begriff suchen]_ +
_Gesch√§ftsprozess: xref:Solution_Design_Concept.adoc#sdc-bp-suche[Fachliche Konstrukte recherchieren]_

[[sydc-scenario-index]]
=== Szenario: Index f√ºr Content Search aktualisieren

*Ziel:* Nach dem Upload oder der √Ñnderung eines Templates wird der Suchindex automatisch aktualisiert.

1. Ein Template-Designer l√§dt ein neues Template hoch oder aktualisiert ein bestehendes Template in blocpress-workbench
2. blocpress-workbench speichert das Template im Schema `workbench` (PostgreSQL) und aktualisiert die Metadaten
3. blocpress-workbench sendet eine Indexierungs-Anfrage an die Content Search Engine (Elasticsearch)
4. Die Content Search Engine extrahiert den Textinhalt des Templates (inkl. User-Fields, statischer Text, Tabellen)
5. Die Search Engine erstellt oder aktualisiert den Index-Eintrag mit Template-ID, extrahiertem Text und Positionsinformationen
6. Die Search Engine best√§tigt die erfolgreiche Indexierung an blocpress-workbench
7. Bei Verwendung eines Bausteins in einem Template indexiert die Search Engine auch die Beziehung zwischen Baustein und Template

[[sydc-qr]]
== Quality Requirements

*Verf√ºgbarkeit:* blocpress soll eine Verf√ºgbarkeit von 99,5% w√§hrend Gesch√§ftszeiten (Mo-Fr, 08:00-18:00 Uhr) erreichen. Geplante Wartungsfenster au√üerhalb der Gesch√§ftszeiten sind zul√§ssig.

*Performance - Dokumentengenerierung:* Die Generierung eines Standard-Dokuments (bis 20 Seiten, bis 10 Wiederholungsgruppen) soll innerhalb von 5 Sekunden abgeschlossen sein. Bei gr√∂√üeren Dokumenten (20-100 Seiten) wird eine Generierungszeit von bis zu 30 Sekunden akzeptiert.

*Performance - Suche:* Die Suche nach fachlichen Konstrukten √ºber alle Templates und Bausteine soll innerhalb von 2 Sekunden Ergebnisse liefern, auch bei einem Bestand von √ºber 1.000 Templates.

*Performance - Regressionstests:* Ein einzelner Regressionstest soll innerhalb von 30 Sekunden abgeschlossen sein. Die parallele Ausf√ºhrung von bis zu 10 Tests soll unterst√ºtzt werden.

*Skalierbarkeit:* Das System soll bis zu 100 gleichzeitige Dokumentengenerierungen verarbeiten k√∂nnen. blocpress-render ist horizontal skalierbar ‚Äî bei Bedarf k√∂nnen weitere Instanzen hinzugef√ºgt werden.

*Zuverl√§ssigkeit:* Die Dokumentengenerierung soll deterministisch sein ‚Äì identische Eingabedaten (Template-Version + JSON-Daten) m√ºssen immer identische Ausgabedokumente erzeugen. Wiederholte Generierungen d√ºrfen keine Abweichungen aufweisen.

*Wartbarkeit:* Alle Templates, Bausteine und generierten Dokumente m√ºssen versioniert werden. √Ñnderungen m√ºssen nachvollziehbar sein und es soll m√∂glich sein, √§ltere Versionen wiederherzustellen.

*Nachvollziehbarkeit (Auditability):* Alle Workflow-Aktionen (Freigaben, Ablehnungen), Compliance-Reviews, Testausf√ºhrungen und API-Zugriffe m√ºssen protokolliert werden. Logs m√ºssen mindestens 2 Jahre aufbewahrt werden.

*Sicherheit - Authentifizierung:* blocpress-studio √ºbernimmt die Authentifizierung und reicht das JWT als Property an Web Components weiter. Jedes SCS-Modul validiert JWTs eigenst√§ndig via Quarkus SmallRye JWT. Eine Laufzeitabh√§ngigkeit zu einem externen Identity Provider besteht nicht.

*Sicherheit - Autorisierung:* Rollenbasierte Zugriffskontrolle (RBAC) muss implementiert sein. Template-Designer arbeiten in blocpress-workbench, Pr√ºfer (konsolidierte Rolle) in blocpress-proof. Template-Designer d√ºrfen nur Templates erstellen und bearbeiten, aber nicht freigeben.

*Sicherheit - API:* API-Zugriffe m√ºssen √ºber API-Keys oder OAuth 2.0 authentifiziert werden. Rate Limiting (max. 1000 Requests pro Stunde pro API-Key) muss implementiert sein.

*Datenschutz:* Personenbezogene Daten in Templates m√ºssen DSGVO-konform verarbeitet werden. Das System muss die M√∂glichkeit bieten, personenbezogene Daten aus Test Cases und generierten Dokumenten zu l√∂schen.

*Backup & Recovery:* T√§gliche Backups der PostgreSQL-Datenbank (inkl. aller Bin√§rdaten) m√ºssen erfolgen. Das System muss innerhalb von 4 Stunden aus einem Backup wiederhergestellt werden k√∂nnen (Recovery Time Objective: 4h). Datenverlust darf maximal 24 Stunden betragen (Recovery Point Objective: 24h).

*Observability:* Alle SCS-Module unterst√ºtzen OpenTelemetry (OTLP) f√ºr den Export von Traces, Metriken und Logs. Die Konfiguration eines OTLP-Endpoints ist optional ‚Äî ohne Endpoint laufen die Module ohne externe Monitoring-Abh√§ngigkeit. Quarkus Health-Checks (`/q/health/live`, `/q/health/ready`) stehen je Modul unabh√§ngig zur Verf√ºgung.

_Fachliche Quality Requirements: xref:Solution_Design_Concept.adoc#sdc-qr[Quality Requirements im Solution Design Concept]_ +
_Element-spezifische Quality Requirements: xref:Element_Design_Concept.adoc#edc-qr[Quality Requirements im Element Design Concept]_

== Testing Approach

**Pragmatischer Test-Ansatz:**

blocpress verfolgt einen pragmatischen Test-Ansatz, der **funktionale Korrektheit und echte Bug-Erkennung vor Instrumentation-Metriken** priorisiert:

*Kernprinzipien:*

1. **Integration Tests mit realen Abh√§ngigkeiten:** H2 in-memory Datenbanken f√ºr Test-Isolation
2. **Echtheit vor Mocks:** Tests durchlaufen die komplette Schicht (HTTP ‚Üí REST ‚Üí Business Logic ‚Üí Database)
3. **Bug-Discovery by Scenario:** Echte Datenbank-Szenarien decken Fehler auf, die Mock-Tests √ºbersehen
4. **Determinismus-Validierung:** Expected Result PDFs verifizieren Qualit√§tsziel "Zuverl√§ssigkeit"

*Test-Klassifizierung:*

[cols="1,2,2" options="header"]
|===
| Typ | Zweck | Technologie

| Unit Tests
| Validierungslogik, Parser, Conditions isoliert testen
| JUnit 5, Mockito

| Integration Tests
| Komplette Workflows mit echter Datenbank und REST-API
| JUnit 5, H2, REST-Assured, Quarkus @QuarkusTest

| Regression Tests
| Determinismus: Gleiche Eingabe ‚Üí Gleiche Ausgabe
| PDF-Byte-Vergleiche mit Expected Results
|===

*Erkannte Metriken-Limits:*

- JaCoCo-Coverage f√ºr REST-APIs ist nicht aussagekr√§ftig (Code l√§uft in separatem ClassLoader, HTTP-Marshalling wird nicht instrumentiert)
- Fokus liegt auf **funktionale Testabdeckung** statt Instrumentation-Metriken
- H2-basierte Integration Tests finden echte Fehler (Beweis: 4 Bugs in blocpress-workbench entdeckt und korrigiert)

_Detaillierte Test-Metriken und Erkenntnisse: xref:../product-backlog.adoc#UC-10-1[Test-Strategie im Product Backlog]_

[[sydc-constraints]]
== Constraints

*Technologische Constraints:*

- blocpress ist als Self-Contained Systems (SCS) strukturiert: studio, workbench, proof, render, admin
- Alle SCS-Module (au√üer studio) basieren auf Quarkus Framework
- Jedes SCS-Modul wird als eigener Docker-Container betrieben
- LibreOffice Version ‚â• 24 muss headless in blocpress-render integriert sein (Format-Export). blocpress-workbench nutzt blocpress-core f√ºr Validierung ohne LibreOffice
- Nur LibreOffice-kompatible Formate (ODT, OTT) werden als Template-Format unterst√ºtzt
- Export nach ODT, PDF und RTF
- PostgreSQL Version ‚â• 18 als Datenbank mit vier getrennten Schemata (workbench, proof, production, admin)
- Identische Template-Tabellenstrukturen in workbench/proof/production f√ºr kopie-basierte Stufen√ºbergabe
- Bin√§rdaten werden in PostgreSQL gespeichert (< 5.000 Dokumente + Templates erwartet)
- Storage Abstraction Layer muss implementiert sein, um zuk√ºnftigen Wechsel zu S3-kompatiblem Object Storage zu erm√∂glichen
- Elasticsearch ab Version 7.x f√ºr Content Search

*Datenschutz-Constraints:*

- Verarbeitung personenbezogener Daten muss DSGVO-konform erfolgen
- Templates und generierte Dokumente d√ºrfen nur in der EU bzw. in Regionen mit angemessenem Datenschutzniveau gespeichert werden
- L√∂schkonzept f√ºr personenbezogene Daten muss implementiert sein

*Organisatorische Constraints:*

- Der Freigabeprozess muss eine Vier-Augen-Pr√ºfung gew√§hrleisten (Designer ‚â† Freigeber)
- Compliance-Reviews m√ºssen nach 1, 3 oder 5 Jahren erfolgen (konfigurierbar pro Template)
- Templates ohne g√ºltige Freigabe d√ºrfen nicht f√ºr die Produktiv-Generierung verwendet werden

*Lizenzierungs-Constraints:*

- Verwendung von Open-Source-Komponenten (LibreOffice, PostgreSQL, Elasticsearch) unter Einhaltung der jeweiligen Lizenzbedingungen
- Kommerzielle Komponenten (falls verwendet) m√ºssen lizenziert werden

*Infrastruktur-Constraints:*

- Das System muss in der bestehenden Container-Infrastruktur (Docker/Kubernetes) der Organisation betrieben werden k√∂nnen
- JWT-Validierung mittels konfiguriertem Issuer und Public Key ist erforderlich (kein externer Identity Provider zur Laufzeit)
- OpenTelemetry (OTLP) f√ºr Observability; Konfiguration eines Collectors ist optional
- Integration in bestehendes Backup-System muss m√∂glich sein

*Compliance-Constraints:*

- Review-Zyklen und deren Dokumentation m√ºssen branchenspezifischen Compliance-Anforderungen entsprechen (z.B. ISO 9001, branchenspezifische Vorgaben)
- Audit-Logs m√ºssen manipulationssicher gespeichert werden
- √Ñnderungen an Templates m√ºssen l√ºckenlos nachvollziehbar sein

_Fachliche Constraints: xref:Solution_Design_Concept.adoc#sdc-constraints[Constraints im Solution Design Concept]_ +
_Element-spezifische Constraints: xref:Element_Design_Concept.adoc#edc-constraints[Constraints im Element Design Concept]_