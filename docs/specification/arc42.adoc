ifndef::imagesdir[:imagesdir: ../images]
ifndef::imagesdir[]:imagesdir]

image:blocpress-logo-large.png[]

= Architecture Documentation
:revnumber: 1.0
:revdate: {docdate}
:revremark: Initiale Version

:toc-title: Inhaltsverzeichnis
:keywords: software-architecture, documentation, blocpress, template-engine, document-generation
:numbered:

[[section-introduction-and-goals]]
== Einf√ºhrung und Ziele

blocpress ist ein template-basierter Print-Server zur automatisierten Generierung professioneller Dokumente. Das System f√ºhrt LibreOffice-Templates (ODT) mit strukturierten JSON-Daten zusammen und erzeugt Dokumente in den Formaten ODT, PDF und RTF.

=== Aufgabenstellung

*Kernaufgabe:* blocpress erm√∂glicht die automatisierte, qualit√§tsgesicherte und compliance-konforme Erstellung von Dokumenten aus Templates.

*Wesentliche funktionale Anforderungen:*

* *Template-Verwaltung:* Zentrale Speicherung und Versionierung von LibreOffice-Templates und wiederverwendbaren Bausteinen
* *Dokumentengenerierung:* Automatisierte Bef√ºllung von Templates mit JSON-Daten √ºber REST-API
- User-Fields in Punkt-Notation (z.B. `kunde.name`)
- Wiederholungsgruppen f√ºr Arrays (Sections und Tables)
- IF-Bedingungen f√ºr dynamische Inhalte
- Export in ODT, PDF und RTF
* *Workflow-gesteuerte Freigabe:* Mehrstufiger Freigabeprozess mit Vier-Augen-Prinzip (Designer ‚â† Freigeber)
* *Compliance-Management:* Automatische √úberwachung turnusm√§√üiger Reviews (1, 3 oder 5 Jahre)
* *Test-Framework:* Verwaltung von Testdaten, Baseline-PDFs und automatisierte Regressionstests
* *Content Search:* Performante Volltextsuche nach fachlichen Konstrukten √ºber alle Templates

*Treibende Kr√§fte:*

* Transformation von manueller, fehleranf√§lliger Dokumentenerstellung zu automatisiertem Workflow
* Sicherstellung inhaltlicher Aktualit√§t durch turnusm√§√üige Reviews
* Konsistenz √ºber alle Dokumente durch zentrale Template-Verwaltung
* Qualit√§tssicherung durch Freigabeprozess und Regressionstests

*Referenzen:*

* xref:Solution_Design_Concept.adoc#sdc-vision[Solution Design Concept: blocpress] -- Vision, Value Creation Architecture, Information Architecture, Business Processes
* xref:System_Design_Concept.adoc#sydc-goals[System Design Concept: blocpress] -- Systemziele, Systemarchitektur, Szenarien
* xref:Element_Design_Concept.adoc#edc-goals[Element Design Concept: blocpress (SCS-Module)] -- Goals, Use Cases, Technical Functions, Entities

=== Qualit√§tsziele

[cols="1,2,3,1" options="header"]
|===
| Priorit√§t | Qualit√§tsziel | Szenario | Kapitel

| 1
| *Performance*
| Dokumentengenerierung f√ºr Standard-Dokumente (bis 20 Seiten) innerhalb von 5 Sekunden. Suche √ºber alle Templates innerhalb von 2 Sekunden.
| 10.2

| 2
| *Zuverl√§ssigkeit (Determinismus)*
| Identische Eingaben (Template + JSON-Daten) erzeugen immer identische Ausgabedokumente. Essentiell f√ºr Regressionstests.
| 10.1

| 3
| *Wartbarkeit*
| Templates und Code m√ºssen versioniert sein. √Ñnderungen nachvollziehbar. Storage Abstraction Layer erm√∂glicht Wechsel zu S3.
| 9, 10.3

| 4
| *Sicherheit*
| Vier-Augen-Prinzip (Designer ‚â† Freigeber) technisch erzwungen. RBAC f√ºr alle Funktionen. API-Rate-Limiting.
| 2.3, 10.4

| 5
| *Skalierbarkeit*
| Horizontal skalierbar: Bis zu 100 gleichzeitige Dokumentengenerierungen. Asynchrone Verarbeitung √ºber Message Queue.
| 8.1, 10.5
|===

=== Stakeholder

[cols="1,1,2" options="header"]
|===
| Rolle | Kontakt | Erwartungshaltung

| Template-Designer
| Fachabteilungen
| Einfaches Erstellen von Templates in vertrauter LibreOffice-Umgebung. Klare Validierungsmeldungen. Eigene Arbeitsumgebung (blocpress-workbench).

| Pr√ºfer (QM / Freigeber / Compliance)
| QS- / Compliance-Abteilung
| Strukturierter Freigabeprozess mit Vier-Augen-Prinzip. Testm√∂glichkeiten mit Beispieldaten. √úbersichtliche Darstellung f√§lliger Compliance-Reviews. Eigene Arbeitsumgebung (blocpress-proof).

| Entwicklungsteams
| IT-Abteilung
| Stabile REST-API f√ºr Dokumentengenerierung (blocpress-render). Gute Performance (< 5s). Klare Fehlermeldungen.

| Administratoren
| IT-Betrieb
| Einfache Installation als Docker-Container. Monitoring-Integration. RBAC-Verwaltung (blocpress-admin).

| Architekten
| IT-Architektur
| Klare Architektur. Modularer Aufbau. Technologie-Stack: Quarkus, PostgreSQL, LibreOffice.

| Projektleitung
| Management
| Einhaltung von Compliance-Vorgaben. Wirtschaftlicher Betrieb (< 5.000 Dokumente in PostgreSQL).
|===

<<<<
[[section-architecture-constraints]]
== Randbedingungen

=== Technische Randbedingungen

_Detaillierte Constraints: xref:Element_Design_Concept.adoc#edc-constraints[Constraints im Element Design Concept] | xref:Solution_Design_Concept.adoc#sdc-constraints[Constraints im Solution Design Concept]_

[cols="1,2" options="header"]
|===
| Randbedingung | Erl√§uterung

| Quarkus Framework
| Alle SCS-Module m√ºssen mit Quarkus implementiert werden (schnelle Startup-Zeit, geringer Memory-Footprint, native Kompilierung m√∂glich).

| LibreOffice ‚â• 24
| LibreOffice Version 24 oder h√∂her muss headless in blocpress-render integriert sein. √Ñltere Versionen nicht unterst√ºtzt.

| PostgreSQL ‚â• 18
| Datenbank muss PostgreSQL Version 18 oder h√∂her sein. JSONB-Indizes erforderlich.

| Docker-Container
| blocpress muss als Docker-Container betreibbar sein. Kubernetes-Deployment optional.

| Template-Format
| Nur ODT und OTT als Template-Eingabeformat. DOCX/DOC nicht unterst√ºtzt.

| Export-Formate
| Nur ODT, PDF und RTF als Ausgabeformat. DOCX/HTML nicht unterst√ºtzt.

| Elasticsearch ‚â• 7.x
| Content Search Engine basiert auf Elasticsearch 7.x oder h√∂her.

| Message Queue
| RabbitMQ oder Kafka f√ºr asynchrone Dokumentengenerierung.
|===

=== Organisatorische Randbedingungen

[cols="1,2" options="header"]
|===
| Randbedingung | Erl√§uterung

| Vier-Augen-Prinzip
| Designer darf nicht gleichzeitig Freigeber sein. Technisch erzwungen durch TF-2.

| Compliance-Reviews
| Templates mit rechtlicher/regulatorischer Relevanz m√ºssen nach 1, 3 oder 5 Jahren zur Review vorgelegt werden.

| Freigabe-Pflicht
| Templates ohne Status "Freigegeben" d√ºrfen nicht f√ºr Produktiv-Generierung verwendet werden.

| JWT-basierte Authentifizierung
| Benutzer-Authentifizierung erfolgt √ºber JWT-Validierung. Jedes SCS-Modul pr√ºft Signatur, Issuer und Ablaufdatum gegen einen konfigurierten Public Key. Kein externer Identity Provider zur Laufzeit erforderlich.
|===

=== Konventionen

[cols="1,2" options="header"]
|===
| Konvention | Erl√§uterung

| RESTful API Design
| REST-API folgt RESTful Prinzipien: Ressourcen-orientiert, HTTP-Verben, JSON-Response.

| JSON-Punkt-Notation
| User-Fields referenzieren JSON-Pfade in Punkt-Notation: `kunde.name`, `vertrag.positionen[0].preis`

| Storage Abstraction Layer
| Zugriff auf Bin√§rdaten nur √ºber `StorageService` Interface. Erm√∂glicht zuk√ºnftigen Wechsel zu S3.

| Audit-Logging
| Alle Workflow-√Ñnderungen, Freigaben und Reviews m√ºssen audit-log-tauglich protokolliert werden.
|===

<<<<
[[section-context-and-scope]]
== Kontextabgrenzung

=== Fachlicher Kontext

[plantuml, fachlicher-kontext, svg]
----
@startuml
!define RECTANGLE class

skinparam componentStyle rectangle

actor "Template-Designer" as Designer
actor "Pr√ºfer\n(QM / Freigeber / Compliance)" as Pruefer
actor "Administrator" as Admin

rectangle "Anwendungssystem" as App

rectangle "blocpress" as System {
  component "blocpress-studio\n(Portal)" as Studio
  component "blocpress-workbench\n(Entwicklung)" as Workbench
  component "blocpress-proof\n(Pr√ºfung & Freigabe)" as Proof
  component "blocpress-admin\n(Administration)" as AdminSCS
  component "blocpress-render\n(Dokumentengenerierung)" as Render
}

rectangle "OpenTelemetry Collector" as Monitor

Designer --> Workbench : Templates hochladen\nBausteine verwalten
Pruefer --> Proof : Templates pr√ºfen\nFreigeben/Ablehnen\nCompliance-Reviews
Admin --> AdminSCS : Benutzer verwalten\nSystem konfigurieren

Designer --> Studio : Login / Navigation
Pruefer --> Studio : Login / Navigation
Admin --> Studio : Login / Navigation

App --> Render : Dokumente generieren\n(REST-API)

System --> Monitor : Traces, Metriken & Logs\n(OTLP)
@enduml
----

*Kommunikationsbeziehungen:*

[cols="1,2,1" options="header"]
|===
| Partner | Eingabe | Ausgabe

| Template-Designer
| ODT-Templates, Bausteine, Metadaten
| Validierungsergebnisse, Template-Status, Vorschau-Dokumente

| Pr√ºfer (QM / Freigeber / Compliance)
| Pr√ºfkommentare, Freigabe-/Ablehnungsentscheidung, Review-Ergebnisse, JSON-Testdaten, Baseline-Updates
| Templates zur Pr√ºfung, Testdokumente, f√§llige Reviews, Test-Ergebnisse, PDF-Vergleiche

| Administrator
| Benutzerdaten, Rollen, System-Konfiguration
| Benutzerliste, Audit-Logs, System-Status

| Anwendungssystem
| Template-ID, JSON-Daten, gew√ºnschtes Format
| Generiertes Dokument (ODT/PDF/RTF), Generierungs-ID, Status

| OpenTelemetry Collector (optional)
| (keine Eingabe)
| Traces, Metriken und Logs via OTLP-Protokoll
|===

=== Technischer Kontext

[plantuml, technischer-kontext, svg]
----
@startuml
!define RECTANGLE class

skinparam componentStyle rectangle

node "Client-Browser" as Browser
node "Externe Anwendung" as ExtApp

node "Docker Host / Kubernetes" as Docker {
  component "blocpress-studio\n(Portal/Shell)" as Studio
  component "Scs-Modules" as ScsModules  {
    component "blocpress-workbench\n(Quarkus)" as Workbench
    component "blocpress-proof\n(Quarkus)" as Proof
    component "blocpress-admin\n(Quarkus)" as Admin
    component "blocpress-render\n(Quarkus)" as Render
  }
  database "PostgreSQL ‚â• 18\n(Schemata: workbench,\nproof, production, admin)" as DB
  queue "RabbitMQ/Kafka" as MQ
  component "Elasticsearch ‚â• 7.x" as ES
}

node "Externe Services (optional)" {
  component "OpenTelemetry\nCollector" as Monitor
}

Browser -down-> Studio : HTTPS/TLS
Studio -down-> Workbench : REST (intern)
Studio -down-> Proof : REST (intern)
Studio -down-> Admin : REST (intern)
ExtApp -down-> Render : REST-API\nJSON over HTTPS

Workbench -down-> DB : JDBC (Schema: workbench)
Proof -down-> DB : JDBC (Schema: proof)
Render -down-> DB : JDBC (Schema: production)
Admin -down-> DB : JDBC (Schema: admin)
Workbench -down-> ES : REST-API\nHTTP/JSON
Render -down-> MQ : AMQP / Kafka Protocol
ScsModules --> Monitor
@enduml
----

*Technische Schnittstellen:*

[cols="1,1,2" options="header"]
|===
| Schnittstelle | Protokoll/Technologie | Mapping fachlicher Daten

| Browser ‚Üí blocpress-studio
| HTTPS, Web Components (Dynamic Import)
| Portal-Shell l√§dt Micro-Frontends der SCS-Module als Web Components

| blocpress-studio ‚Üí SCS-Module (intern)
| REST-API, JSON (intern, nicht √∂ffentlich)
| UI-Aktionen werden an das jeweilige SCS-Modul delegiert

| Externe Anwendung ‚Üí blocpress-render
| HTTPS, REST-API, JSON
| Dokumentengenerierung: `POST /api/documents/generate` (einzige √∂ffentliche API)

| SCS-Module ‚Üí PostgreSQL
| JDBC, PostgreSQL Wire Protocol
| Jedes Modul nutzt eigenes Schema (workbench, proof, production, admin)

| Render ‚Üí RabbitMQ/Kafka
| AMQP (RabbitMQ) / Kafka Protocol
| Asynchrone Dokumentengenerierung, Regressionstests

| blocpress-workbench ‚Üí Elasticsearch
| REST-API, HTTP/JSON
| Template-Indexierung, Volltextsuche (Content Search)

| SCS-Module ‚Üí OpenTelemetry Collector
| OTLP (gRPC Port 4317 / HTTP Port 4318)
| Traces (Request-Verarbeitung), Metriken (Latenz, Fehlerraten), Logs
|===

<<<<
[[section-solution-strategy]]
== L√∂sungsstrategie

=== Technologieentscheidungen

[cols="1,2,2" options="header"]
|===
| Entscheidung | Begr√ºndung | Qualit√§tsziel

| *Self-Contained Systems (SCS)*
| Fachliche Zerlegung in unabh√§ngig deploybare Module mit eigener UI, eigenem Backend und eigenem Datenbank-Schema. Erleichtert Wartung und Team-Ownership.
| Wartbarkeit, Skalierbarkeit

| *Quarkus Framework*
| Schnelle Startup-Zeit, geringer Memory-Footprint, Cloud-native, native Kompilierung m√∂glich. Jedes SCS-Modul ist eine eigenst√§ndige Quarkus-Anwendung.
| Performance, Skalierbarkeit

| *Micro-Frontends (Web Components)*
| Jedes SCS-Modul liefert eigene UI als Web Components (Custom Elements mit Shadow DOM). Portal-Shell (blocpress-studio) l√§dt diese via Dynamic Import.
| Wartbarkeit, Unabh√§ngigkeit

| *LibreOffice headless ‚â• 24*
| Ausgereiftes ODT-Template-Processing, Export in ODT/PDF/RTF, kostenlos, Open Source
| Funktionale Eignung, Kosteneffizienz

| *PostgreSQL ‚â• 18 ‚Äî Multi-Schema*
| Reife relationale DB. Jedes SCS-Modul nutzt ein eigenes Schema (workbench, proof, production, admin) in derselben Datenbank. Identische Tabellenstrukturen f√ºr Templates in workbench/proof/production erm√∂glichen kopie-basierte Stufen√ºbergabe.
| Zuverl√§ssigkeit, Wartbarkeit

| *Storage Abstraction Layer*
| Erm√∂glicht zuk√ºnftigen Wechsel zu S3 ohne Code-√Ñnderungen in Business-Logik
| Wartbarkeit, Flexibilit√§t

| *Elasticsearch f√ºr Content Search*
| Hochperformante Volltextsuche, Relevanz-Ranking, Highlighting
| Performance (< 2s Suchzeit)

| *Message Queue (RabbitMQ/Kafka)*
| Asynchrone Verarbeitung zeitaufw√§ndiger Operationen, Entkopplung, Skalierbarkeit
| Performance, Skalierbarkeit

| *Docker-Container*
| Jedes SCS-Modul als eigener Container, unabh√§ngig skalierbar
| √úbertragbarkeit, Betriebseffizienz
|===

=== Top-Level-Zerlegung

*Architekturmuster:* Self-Contained Systems (SCS) mit Micro-Frontend-Integration

Die Anwendung ist in f√ºnf fachlich geschnittene Module zerlegt:

[cols="1,2,2" options="header"]
|===
| SCS-Modul | Verantwortung | Datenstufe

| *blocpress-studio*
| Portal-Shell (Quarkus): Navigation, Authentifizierung (JWT), Integration der Micro-Frontends via Dynamic Import. Keine eigene Business-Logik.
| ‚Äî

| *blocpress-workbench*
| Template-Entwicklung: Upload, Validierung, Bearbeitung, Bausteinverwaltung, Content Search, Vorschau-Generierung, **Dashboard mit Status-Filtern und Workflow** (UC-5). Arbeitsumgebung f√ºr Template-Designer.
| Schema `workbench`

| *blocpress-proof*
| Pr√ºfung und Freigabe: Workflow (Vier-Augen-Prinzip), Testdaten, Regressionstests, Compliance-Reviews. Arbeitsumgebung f√ºr Pr√ºfer.
| Schema `proof`

| *blocpress-render*
| Dokumentengenerierung: Einzige √∂ffentliche REST-API. Liest freigegebene Templates aus dem Production-Schema. Stateless.
| Schema `production` (read-only)

| *blocpress-admin*
| Administration: Benutzerverwaltung, Rollenzuweisung, Systemkonfiguration, Audit-Logs.
| Schema `admin`
|===

*Datenstufen und Stufen√ºbergabe:*

Templates durchlaufen drei Stufen mit kopie-basierter √úbergabe:

. *workbench* ‚Üí Designer entwickelt und testet Templates
. *proof* ‚Üí Pr√ºfer f√ºhrt Qualit√§tssicherung, Freigabe und Compliance-Reviews durch
. *production* ‚Üí Freigegebene Templates stehen f√ºr die Dokumentengenerierung bereit

Die √úbergabe erfolgt als Kopie: Das Template wird vom workbench-Schema in das proof-Schema kopiert (√úbergabe in den Review-Prozess), nach Freigabe vom proof-Schema in das production-Schema. F√ºr turnusm√§√üige Erneuerungen kann die aktuelle Baseline aus production in das proof-Schema gezogen werden.

*Micro-Frontend-Architektur:*

* blocpress-studio ist die Portal-Shell (HTML-Seite mit Navigation und Auth-Handling)
* Jedes SCS-Modul liefert seine UI als Web Component (Custom Element mit Shadow DOM)
* Studio l√§dt die Web Components per Dynamic Import von den jeweiligen SCS-Modulen (z.B. `import('http://workbench:8081/components/bp-workbench.js')`)
* JWT wird als Property an jedes Web Component weitergereicht: `<bp-workbench jwt="${token}"></bp-workbench>`
* Shadow DOM kapselt CSS und DOM ‚Äî Module beeinflussen sich nicht gegenseitig

*Interne Kommunikation:*

* SCS-Module kommunizieren untereinander √ºber interne REST-APIs (nicht √∂ffentlich exponiert)
* blocpress-render kann Templates sowohl aus dem production-Schema lesen als auch direkt per REST von workbench/proof empfangen (f√ºr Vorschau/Test-Generierung)

=== Erreichung wichtigster Qualit√§tsziele

*Q1: Performance*

* LibreOffice headless l√§uft in blocpress-render (keine IPC-Overhead)
* Asynchrone Dokumentengenerierung √ºber Message Queue (nicht blockierend)
* Elasticsearch f√ºr schnelle Volltextsuche
* PostgreSQL-Indizes auf h√§ufig abgefragte Spalten (template_id, status, user_id)

*Q2: Zuverl√§ssigkeit (Determinismus)*

* LibreOffice-Verarbeitung strikt sequenziell f√ºr gleiche Template-Version
* Keine Zufallswerte, keine zeitabh√§ngigen Werte in Template-Processing
* Versionierung von Templates: Gleiche Version = gleiche Bin√§rdaten
* Regressionstests validieren Determinismus automatisch

*Q3: Wartbarkeit*

* SCS-Architektur: Module unabh√§ngig entwickelbar, testbar und deploybar
* Eigene Datenbank-Schemata: Keine Datenkopplung zwischen Modulen
* Storage Abstraction Layer (`StorageService` Interface) entkoppelt Business-Logik von Storage-Implementierung
* OpenTelemetry f√ºr Traces, Metriken und Logs (optional, vendor-neutral)

*Q4: Sicherheit*

* TF-2 (Workflow-Status √§ndern) pr√ºft technisch: `userId != template.erstellerId`
* RBAC: Rollen im admin-Schema, Pr√ºfung bei jedem API-Call
* API-Rate-Limiting f√ºr blocpress-render: 1.000 Requests/h pro API-Key
* HTTPS/TLS f√ºr alle externen Verbindungen
* JWT-Weitergabe an Web Components √ºber Properties (kein LocalStorage)

*Q5: Skalierbarkeit*

* SCS-Module unabh√§ngig skalierbar: blocpress-render kann separat horizontal skaliert werden
* Message Queue entkoppelt Request-Handling von Dokumentengenerierung
* PostgreSQL Connection Pooling (HikariCP) pro Modul
* Caching von Templates (Caffeine Cache) in blocpress-render

=== Organisatorische Entscheidungen

* *Entwicklungsprozess:* Agil Kanban
* *CI/CD:* Automatische Tests bei jedem Commit, je SCS-Modul
* *Dokumentation:* arc42 f√ºr Architektur, Javadoc f√ºr Code, OpenAPI f√ºr REST-API
* *Team-Ownership:* Jedes SCS-Modul kann von einem eigenen Team verantwortet werden

<<<<
[[section-building-block-view]]
== Bausteinsicht

_Detaillierte Beschreibung der Bausteine: xref:Element_Design_Concept.adoc#edc-functions[Technical Functions] | xref:Element_Design_Concept.adoc#edc-interfaces[Technical Interfaces] | xref:Element_Design_Concept.adoc#edc-usecases[Use Cases]_

=== Whitebox Gesamtsystem

[plantuml, bausteinsicht-ebene1, svg]
----
@startuml
!define RECTANGLE class

skinparam componentStyle rectangle

package "blocpress Gesamtsystem" {
  component "blocpress-studio\n(Portal-Shell)" as Studio

  component "blocpress-workbench\n(Quarkus)" as Workbench
  component "blocpress-proof\n(Quarkus)" as Proof
  component "blocpress-render\n(Quarkus)" as Render
  component "blocpress-admin\n(Quarkus)" as Admin

  component "blocpress-core\n(Shared Library)" as Core

  database "PostgreSQL\n(workbench | proof |\nproduction | admin)" as DB
  queue "Message Queue\n(RabbitMQ)" as MQ
  component "Content Search\n(Elasticsearch)" as Search
}

Studio -down-> Workbench : Web Component\n+ REST (intern)
Studio -down-> Proof : Web Component\n+ REST (intern)
Studio -down-> Admin : Web Component\n+ REST (intern)

Workbench -down-> DB : JDBC\n(Schema: workbench)
Proof -down-> DB : JDBC\n(Schema: proof)
Render -down-> DB : JDBC\n(Schema: production)
Render -right-> MQ : AMQP
Admin -down-> DB : JDBC\n(Schema: admin)

Workbench -down-> Search : HTTP
Workbench ..> Render : REST (intern)\n(Vorschau)
Proof ..> Render : REST (intern)\n(Test-Generierung)

Workbench ..> Core : Maven-\nAbh√§ngigkeit
Render ..> Core : Maven-\nAbh√§ngigkeit
Proof ..> Core : Maven-\nAbh√§ngigkeit

note right of Studio
  Portal-Shell (Quarkus):
  - Navigation
  - JWT-Authentifizierung
  - Dynamic Import f√ºr
    Web Components
end note

note right of Render
  Einzige √∂ffentliche API:
  POST /api/documents/generate
  Liest aus Schema: production
end note
@enduml
----

*Begr√ºndung:*

Die Zerlegung folgt dem Self-Contained-Systems-Ansatz (SCS):

* *blocpress-studio* ist die Portal-Shell ‚Äî l√§dt Micro-Frontends der fachlichen Module als Web Components
* *blocpress-workbench* enth√§lt die Logik f√ºr Template-Entwicklung (Dev-Stufe)
* *blocpress-proof* enth√§lt die Logik f√ºr Pr√ºfung, Freigabe und Compliance (Test/QA-Stufe)
* *blocpress-render* ist die einzige √∂ffentliche API f√ºr Dokumentengenerierung (Production-Stufe)
* *blocpress-admin* verwaltet Benutzer, Rollen und Systemkonfiguration
* *PostgreSQL* nutzt getrennte Schemata pro Modul ‚Äî identische Tabellenstrukturen f√ºr Templates erm√∂glichen kopie-basierte Stufen√ºbergabe
* *Message Queue* erm√∂glicht asynchrone Verarbeitung
* *Elasticsearch* ist spezialisiert auf Volltextsuche (genutzt von blocpress-workbench)

*Enthaltene Bausteine:*

[cols="1,2" options="header"]
|===
| Name | Verantwortung

| blocpress-studio
| Portal-Shell (Quarkus): Authentifizierung (JWT-Handling), Navigation, Laden der Micro-Frontends via Dynamic Import. Keine eigene Business-Logik ‚Äî liefert statische HTML/JS-Assets aus und l√§dt Web Components dynamisch von den SCS-Modulen.

| blocpress-workbench
| Template-Entwicklung: Upload, Validierung (TF-1 via blocpress-core), Bearbeitung, Bausteinverwaltung, Content Search, Vorschau-Generierung. Use Cases: UC-1 bis UC-5, UC-19 bis UC-21.

| blocpress-proof
| Pr√ºfung und Freigabe: Workflow (TF-2, Vier-Augen-Prinzip), Testdaten (UC-14 bis UC-18), Regressionstests (TF-6), Compliance-Reviews (TF-7, UC-11 bis UC-13), Freigabe (UC-6 bis UC-9). Stufen√ºbergabe proof ‚Üí production.

| blocpress-render
| Dokumentengenerierung: Einzige √∂ffentliche REST-API (TI-1). Liest freigegebene Templates aus Schema `production`. Nutzt blocpress-core (Merge-Pipeline) und LibreOffice (Format-Export). Stateless, horizontal skalierbar.

| blocpress-admin
| Administration: Benutzerverwaltung (UC-22 bis UC-24), Rollenzuweisung, Systemkonfiguration, Audit-Logs.

| PostgreSQL Datenbank
| Persistente Speicherung mit getrennten Schemata: `workbench`, `proof`, `production`, `admin`. Identische Template-Tabellenstrukturen in workbench/proof/production.

| Message Queue
| Asynchrone Verarbeitung zeitaufw√§ndiger Operationen (Dokumentengenerierung, Regressionstests). Entkopplung.

| blocpress-core
| Shared Java-Library (Maven-Abh√§ngigkeit, kein eigenst√§ndiger Container): ODT-Parsing (odfdom), Template-Validierung, Merge-Pipeline (Text-Block-Expansion, Bedingungen, Schleifen, Feldersetzung). Wird von blocpress-workbench (Validierung) und blocpress-render (Merge + Generierung) genutzt. Keine LibreOffice-Abh√§ngigkeit.

| Content Search (Elasticsearch)
| Indexierung von Template-Inhalten, Volltextsuche nach fachlichen Konstrukten, Highlighting. Genutzt von blocpress-workbench.
|===

*Wichtige Schnittstellen:*

* *TI-1 (REST-API):* √ñffentliche API von blocpress-render f√ºr externe Anwendungen
* *Interne REST-APIs:* Kommunikation zwischen SCS-Modulen (nicht √∂ffentlich exponiert)
* *TI-2 (Datenbank-Interface):* JDBC-Zugriff pro Modul auf eigenes PostgreSQL-Schema
* *TI-5 (Message Queue Interface):* AMQP-Zugriff auf RabbitMQ
* *TI-7 (Elasticsearch API):* HTTP-REST-Zugriff auf Elasticsearch

=== Ebene 2

==== Whitebox blocpress-workbench

[plantuml, bausteinsicht-ebene2-workbench, svg]
----
@startuml
!define RECTANGLE class

skinparam componentStyle rectangle

package "blocpress-workbench (Quarkus)" {
  component "REST-API\nController" as API
  component "Template\nService" as TS
  component "Baustein\nService" as BS
  component "Search\nService" as SS
  component "Storage\nService" as Storage
  component "Repository\nLayer" as Repo
  component "Web Component\n(bp-workbench)" as WC
}

component "blocpress-core\n(Shared Library)" as Core

WC ..> API : REST
API -down-> TS : aufrufen
API -down-> BS : aufrufen
API -down-> SS : aufrufen
TS -down-> Core : TF-1\n(Validierung)
TS -down-> Storage : save/load
TS -down-> Repo : CRUD
BS -down-> Repo : CRUD
SS -down-> "Elasticsearch" : HTTP

note right of WC
  Custom Element:
  <bp-workbench jwt="...">
  Shadow DOM gekapselt
end note

note right of Core
  ODT-Parsing, Validierung
  Kein LibreOffice n√∂tig
end note
@enduml
----

==== Whitebox blocpress-proof

[plantuml, bausteinsicht-ebene2-proof, svg]
----
@startuml
!define RECTANGLE class

skinparam componentStyle rectangle

package "blocpress-proof (Quarkus)" {
  component "REST-API\nController" as API
  component "Workflow\nEngine" as WF
  component "Compliance\nManager" as CM
  component "Test\nFramework" as TestFW
  component "Staging\nService" as Stage
  component "Repository\nLayer" as Repo
  component "Web Component\n(bp-proof)" as WC
}

WC ..> API : REST
API -down-> WF : aufrufen
API -down-> CM : aufrufen
API -down-> TestFW : aufrufen
API -down-> Stage : aufrufen
WF -down-> Repo : CRUD
CM -down-> Repo : CRUD
TestFW -down-> Repo : CRUD
Stage -down-> Repo : CRUD
Stage --> "blocpress-render" : REST (intern)

note right of Stage
  Stufen√ºbergabe:
  proof ‚Üí production (Kopie)
  production ‚Üí proof (Baseline)
end note
@enduml
----

==== Whitebox blocpress-render

[plantuml, bausteinsicht-ebene2-render, svg]
----
@startuml
!define RECTANGLE class

skinparam componentStyle rectangle

package "blocpress-render (Quarkus)" {
  component "REST-API\nController\n(√∂ffentlich)" as API
  component "Document\nService" as DS
  component "LibreOffice\nProcessor" as LO
  component "Storage\nService" as Storage
  component "Repository\nLayer" as Repo
}

component "blocpress-core\n(Shared Library)" as Core

API -down-> DS : aufrufen
DS -down-> Core : Merge-Pipeline\n(TF-5 Schritt 1-4)
DS -down-> LO : Format-Export\n(TF-5 Schritt 5)
DS -down-> Storage : save/load
DS -down-> Repo : read
Repo -down-> "PostgreSQL\n(Schema: production)" : JDBC

note right of Core
  ODT-Parsing, Merge-Pipeline:
  Text-Bl√∂cke, Bedingungen,
  Schleifen, Feldersetzung
  (reines Java/odfdom)
end note

note right of LO
  LibreOffice ‚â• 24
  headless: nur Format-Export
  ODT ‚Üí PDF / RTF
end note

note right of Storage
  Storage Abstraction Layer
  Interface: save/load
  Impl: PostgresStorageService
  Future: S3StorageService
end note
@enduml
----

*Begr√ºndung der internen Zerlegung:*

Jedes SCS-Modul folgt intern einer Schichtenarchitektur mit Dependency Inversion:

* REST-API Controller delegieren an fachliche Services
* Fachliche Services orchestrieren Technical Functions
* Technical Functions nutzen Infrastructure Services (LibreOffice, Storage, Repository)
* Storage Abstraction Layer erm√∂glicht Austausch der Storage-Implementierung

==== Blackbox blocpress-core (Shared Library)

*Zweck/Verantwortung:*

Gemeinsame Java-Library f√ºr ODT-Parsing, Template-Validierung und Merge-Pipeline. Wird als Maven-Abh√§ngigkeit von blocpress-workbench und blocpress-render genutzt. Keine LibreOffice-Abh√§ngigkeit ‚Äî rein odfdom-basiert.

*Schnittstellen:*

* `RenderEngine.mergeTemplate(URL template, JsonNode data): OdtTemplateDocument` ‚Äî Merge-Pipeline (Text-Block-Expansion, Bedingungen, Schleifen, Feldersetzung)
* `TemplateValidator.validate(byte[] odtBinary): ValidationResult` ‚Äî Struktur-Analyse, User-Fields, Wiederholungsgruppen, IF-Bedingungen extrahieren
* `OdtTemplateDocument` / `OdtTemplateElement` ‚Äî Abstraktionen √ºber odfdom

*Qualit√§ts-/Leistungsmerkmale:*

* Deterministisch: Gleiche Eingabe ‚Üí gleiche Ausgabe (Merge-Ergebnis)
* Kein externes Prozess-Management: Reine In-Process-Verarbeitung
* Testbar ohne LibreOffice-Installation

*Ablageort/Datei:*

* Maven-Modul: `blocpress-core`
* Package: `io.github.flaechsig.blocpress.core`
* Hauptklassen: `RenderEngine`, `OdtTemplateDocument`, `OdtTemplateElement`, `JexlConditionEvaluator`

==== Blackbox LibreOffice Processor

*Zweck/Verantwortung:*

Format-Konvertierung von ODT-Dokumenten nach PDF und RTF via LibreOffice headless. Wird in blocpress-render (Dokumentengenerierung) eingesetzt. Blocpress-workbench nutzt LibreOffice nicht ‚Äî die Validierung l√§uft vollst√§ndig √ºber blocpress-core.

*Schnittstellen:*

* `exportDocument(byte[] mergedOdt, OutputFormat format): byte[]` ‚Äî Konvertiert ein bereits gemergtes ODT in das Zielformat (PDF/RTF/ODT)

*Qualit√§ts-/Leistungsmerkmale:*

* Deterministisch: Gleiche Eingabe ‚Üí gleiche Ausgabe
* Performance: < 5s f√ºr Standard-Dokumente (20 Seiten)
* Thread-Safe: Mehrere parallele LibreOffice-Instanzen m√∂glich

*Ablageort/Datei:*

* Maven-Modul: `blocpress-render`
* Package: `io.github.flaechsig.blocpress.render`
* Hauptklasse: `LibreOfficeProcessor`

==== Blackbox Storage Service

*Zweck/Verantwortung:*

Abstraktionsschicht f√ºr Speicherung von Bin√§rdaten (Templates, generierte Dokumente, Test-PDFs). Wird in jedem SCS-Modul mit eigenem Schema eingesetzt.

*Schnittstellen:*

* `save(byte[] data, String key): StorageId`
* `load(StorageId id): byte[]`
* `delete(StorageId id): void`

*Qualit√§ts-/Leistungsmerkmale:*

* Austauschbar: Interface erlaubt Wechsel von PostgreSQL zu S3 ohne Code-√Ñnderungen in Business-Logik
* Performance: Optimiert f√ºr < 5.000 Dokumente in PostgreSQL
* Transaktional: Speicherung in PostgreSQL erfolgt transaktional mit Metadaten

<<<<
[[section-runtime-view]]
== Laufzeitsicht

_Systemszenarien: xref:System_Design_Concept.adoc#sydc-scenarios[System Scenarios im System Design Concept] | Business Processes: xref:Solution_Design_Concept.adoc#sdc-bp[Business Processes im Solution Design Concept]_

=== Template hochladen und validieren

*Szenario:* Template-Designer l√§dt neues ODT-Template in blocpress-workbench hoch (UC-1)

[plantuml, laufzeit-template-upload, svg]
----
@startuml
actor "Template-Designer" as User
participant "blocpress-studio\n(Portal-Shell)" as Studio
participant "bp-workbench\n(Web Component)" as WC
participant "blocpress-workbench\nREST-API" as API
participant "TemplateService\n(UC-1)" as UC
participant "LibreOfficeProcessor\n(TF-1)" as LO
participant "StorageService" as Storage
participant "Repository\n(Schema: workbench)" as Repo
participant "Elasticsearch" as ES

User -> Studio : Login (JWT)
Studio -> WC : <bp-workbench jwt="...">
User -> WC : Upload ODT-Datei
WC -> API : POST /api/templates\n(multipart/form-data + JWT)
API -> UC : uploadTemplate(file, name, desc)
UC -> LO : validateTemplate(odtBinary)
LO -> LO : LibreOffice UNO-API:\nDokument √∂ffnen,\nUser-Fields extrahieren,\nWiederholungsgruppen identifizieren
LO --> UC : ValidationResult\n(isValid, userFields, ...)
UC -> Storage : save(odtBinary, key)
Storage --> UC : StorageId
UC -> Repo : save(Template entity)
Repo --> UC : Template (id, ...)
UC -> ES : indexTemplate(templateId, content)
ES --> UC : OK
UC --> API : TemplateDTO
API --> WC : 201 Created + JSON
WC --> User : Template-Details anzeigen

note right of LO
  TF-1: Template validieren
  L√§uft in blocpress-workbench
  Schema: workbench
end note
@enduml
----

=== TestDataSet-Verwaltung und lokale Regression-Tests (blocpress-workbench)

*Szenario:* Template-Designer erstellt Test-Datens√§tze und speichert PDF-Baselines f√ºr lokale Regression-Tests (UC-20, UC-21, TF-8, UC-11)

[plantuml, laufzeit-testdata-management, svg]
----
@startuml
actor "Template-Designer" as User
participant "blocpress-workbench\n(Web Component)" as WC
participant "blocpress-workbench\nREST-API" as API
participant "TestDataSetService" as Service
participant "RenderService" as Render
participant "StorageService" as Storage
participant "Repository\n(Schema: workbench)" as Repo

User -> WC : Tab "Testdaten" √∂ffnen
WC -> API : GET /templates/{id}/testdata
API -> Service : listTestDataSets(templateId)
Service -> Repo : findByTemplateId(templateId)
Repo --> Service : List<TestDataSet>
Service --> API : TestDataSetDTO[]
API --> WC : JSON Array
WC --> User : Testdaten-Liste anzeigen

User -> WC : "+ Neu" Button klicken
WC --> User : Auto-generiertes Formular\n(aus template.validationResult.userFields)

User -> WC : Testdaten eingeben\n(z.B. customer.name, amount)
User -> WC : "Speichern" Button
WC -> API : POST /templates/{id}/testdata\n{name, testData: {...}}
API -> Service : createTestDataSet(templateId, name, data)
Service -> Service : validateTestData(template, data)
Service -> Repo : persist(testDataSet)
Repo --> Service : TestDataSet (with id)
Service --> API : TestDataSetDTO
API --> WC : 201 Created
WC --> User : "TestDataSet erstellt"

note right of Service
  UC-20: Auto-generiertes Formular\naus template.validationResult.userFields
  UC-21: Mehrere TestDataSets pro Template
end note

== PDF als Expected Result speichern ==

User -> WC : Testdaten-Item ‚Üí "Vorschau" klicken
WC -> WC : Tab wechselt zu "Vorschau"
WC -> Render : POST /api/render/template\n(template + testData)
Render --> WC : pdfBlob
WC --> User : PDF wird angezeigt

User -> WC : "PDF speichern" Button
WC -> API : POST /templates/{id}/testdata/{dataId}/save-expected\n(pdfBlob als octet-stream)
API -> Service : saveExpectedPdf(testDataSetId, pdfContent)
Service -> Service : hash = SHA256(pdfContent)
Service -> Storage : save(pdfContent)
Storage --> Service : storageId
Service -> Repo : updateTestDataSet(hash, storageId)
Repo --> Service : OK
Service --> API : {hash, message}
API --> WC : 200 OK
WC --> User : "Expected PDF gespeichert"

note right of Service
  TF-8: PDF-Speichern als Baseline\nf√ºr Regression-Tests
  UC-11: Hash f√ºr schnelle Vergleiche
end note

== Regression-Test vorbereiten ==

User -> WC : Testdaten-Item mit Expected PDF ‚Üí "Vorschau"
WC -> WC : Tab "Vorschau", Testdaten laden
WC -> Render : PDF mit aktuellem Template generieren
Render --> WC : currentPdf
WC --> User : PDF anzeigen (mit Hash-Info)

note right of WC
  Zuk√ºnftig (Phase 4): Automatischer Vergleich
  mit Expected PDF und Diff-Visualisierung
end note

@enduml
----

=== Dokument √ºber API generieren (asynchron)

*Szenario:* Externe Anwendung generiert Dokument √ºber blocpress-render (UC-10, TF-5)

[plantuml, laufzeit-doc-generation, svg]
----
@startuml
participant "Externe\nAnwendung" as App
participant "blocpress-render\nREST-API\n(√∂ffentlich)" as API
participant "DocumentService\n(UC-10)" as UC
participant "Message Queue" as MQ
participant "DocumentWorker" as Worker
participant "LibreOfficeProcessor\n(TF-5)" as LO
participant "StorageService" as Storage
participant "Repository\n(Schema: production)" as Repo

App -> API : POST /api/documents/generate\n{templateId, jsonData, format}
API -> UC : generateDocument(...)
UC -> Repo : createGenerationRecord()\nStatus: "In Bearbeitung"
Repo --> UC : GenerationId
UC -> MQ : sendMessage(generationId, templateId,\njsonData, format)
MQ --> UC : MessageId
UC --> API : GenerationId
API --> App : 202 Accepted\n{generationId}

... Asynchrone Verarbeitung ...

MQ -> Worker : consumeMessage
Worker -> Repo : loadTemplate(templateId)
Repo --> Worker : Template (incl. binary)
Worker -> LO : generateDocument(template,\njsonData, format)
LO -> LO : LibreOffice UNO-API:\n- Template √∂ffnen\n- User-Fields bef√ºllen\n- Wiederholungsgruppen iterieren\n- IF-Bedingungen auswerten\n- Export (ODT/PDF/RTF)
LO --> Worker : documentBinary
Worker -> Storage : save(documentBinary)
Storage --> Worker : StorageId
Worker -> Repo : updateGenerationRecord()\nStatus: "Erfolgreich"
Repo --> Worker : OK

... Polling durch Anwendung ...

App -> API : GET /api/documents/{id}/status
API -> Repo : findById(generationId)
Repo --> API : Document (status, storageId)
API --> App : {status: "Erfolgreich",\ndownloadUrl: "/api/documents/{id}/download"}

App -> API : GET /api/documents/{id}/download
API -> Storage : load(storageId)
Storage --> API : documentBinary
API --> App : 200 OK\nContent-Type: application/pdf\nbinary stream

note right of API
  blocpress-render:
  Einzige √∂ffentliche API
  Liest aus Schema: production
end note
@enduml
----

=== Automatischer Regressionstest

*Szenario:* Nach √úbergabe eines Templates in blocpress-proof werden Regressionstests ausgef√ºhrt (UC-16, TF-6)

[plantuml, laufzeit-regression-test, svg]
----
@startuml
participant "blocpress-proof\nTemplateService" as Template
participant "blocpress-proof\nTestFramework" as TF
participant "Message Queue" as MQ
participant "TestWorker\n(blocpress-proof)" as Worker
participant "blocpress-render\n(intern)" as Render
participant "PDFComparator\n(TF-6)" as Compare
participant "Repository\n(Schema: proof)" as Repo

Template -> TF : templateReceived(templateId)
TF -> Repo : findTestCasesByTemplate(templateId)
Repo --> TF : List<TestCase>

loop f√ºr jeden TestCase
  TF -> MQ : sendTestMessage(testCaseId)
end

MQ -> Worker : consumeMessage(testCaseId)
Worker -> Repo : loadTestCase(testCaseId)
Repo --> Worker : TestCase\n(jsonData, baselinePdf)
Worker -> Render : POST /internal/render\n(template + jsonData)
Render --> Worker : currentPdf
Worker -> Compare : comparePdfs(baselinePdf, currentPdf)
Compare -> Compare : - Seitenanzahl pr√ºfen\n- Text extrahieren\n- Zeile f√ºr Zeile vergleichen
Compare --> Worker : ComparisonResult\n(isIdentical, differences)

alt PDFs identisch
  Worker -> Repo : updateTestCase()\nStatus: "Bestanden"
else PDFs unterschiedlich
  Worker -> Repo : updateTestCase()\nStatus: "Fehlgeschlagen"\ndifferences: [...]
end

Repo --> Worker : OK

note right of Render
  blocpress-render wird intern
  von proof aufgerufen
  (kein Zugriff auf production-Schema)
end note
@enduml
----

=== Template Management Dashboard ‚Äî Status-Filter und Workflow (UC-5)

*Szenario:* Template-Designer verwaltet Templates √ºber Dashboard mit Status-Filtern, f√ºhrt Status-√úberg√§nge durch, dupliziert Produktiv-Templates und aktualisiert DRAFT-Templates

[plantuml, laufzeit-dashboard-workflow, svg]
----
@startuml
actor "Template-Designer" as Designer
participant "bp-workbench\n(Web Component)" as WC
participant "blocpress-workbench\nREST-API" as API
participant "TemplateService\n(UC-5)" as UC
participant "TemplateValidator\n(TF-1)" as Validator
participant "Repository\n(Schema: workbench)" as Repo

== Dashboard-Ansicht ==

Designer -> WC : Workbench √∂ffnen
WC -> API : GET /api/workbench/templates
API -> UC : listTemplates()
UC -> Repo : find("ORDER BY name")
Repo --> UC : List<Template>
UC --> API : List<TemplateSummary>\n(mit isValid, status)
API --> WC : JSON Array
WC --> Designer : Dashboard mit\nTemplate-Cards anzeigen

== Status filtern ==

Designer -> WC : Klick "üß™ Test" Filter
WC --> WC : _statusFilter = 'SUBMITTED'
WC --> Designer : Zeige nur SUBMITTED Templates

== Status-√úbergang ==

Designer -> WC : DRAFT-Template ‚Üí "‚Üí Test" Button
WC -> API : PUT /api/workbench/templates/{id}/status\n{newStatus: "SUBMITTED"}
API -> UC : updateStatus(templateId, SUBMITTED)
UC -> UC : isValidTransition(DRAFT, SUBMITTED) ‚úì
UC -> Repo : template.status = SUBMITTED\npersist()
Repo --> UC : OK
UC --> API : {id, status}
API --> WC : 200 OK
WC --> Designer : Success-Message\nTemplate-Liste neu laden

== Template als DRAFT-Kopie erstellen ==

Designer -> WC : APPROVED-Template ‚Üí "Als Kopie" Button
WC -> WC : Prompt: Name eingeben
Designer -> WC : "Invoice v3"
WC -> API : POST /api/workbench/templates/{id}/duplicate\n{name: "Invoice v3"}
API -> UC : duplicate(sourceId, "Invoice v3")
UC -> UC : Pr√ºfe: Name nicht vorhanden ‚úì
UC -> UC : Kopiere content (byte[])
UC -> Validator : validate(newContent)
Validator --> UC : ValidationResult
UC -> Repo : persist(newTemplate)\nStatus: DRAFT
Repo --> UC : Template (with id)
UC --> API : {id, name, status, isValid}
API --> WC : 201 Created
WC --> Designer : Success-Message\n"Invoice v3" im Filter DRAFT

== Template aktualisieren (Re-Upload) ==

Designer -> WC : DRAFT-Template ‚Üí "Aktualisieren" Button
WC -> WC : File-Dialog √∂ffnen
Designer -> WC : Neue ODT-Datei ausw√§hlen
WC -> API : PUT /api/workbench/templates/{id}/content\n(multipart/form-data, file)
API -> UC : updateContent(templateId, newFile)
UC -> UC : Pr√ºfe: Status = DRAFT ‚úì
UC -> UC : Kopiere newFile ‚Üí content
UC -> Validator : validate(newContent)
Validator --> UC : ValidationResult (neu)
UC -> Repo : template.content = newContent\ntemplate.validationResult = new\npersist()
Repo --> UC : OK
UC --> API : {id, name, status, isValid, errors, warnings}
API --> WC : 200 OK
WC --> Designer : Success-Message\n"Template aktualisiert"

note right of UC
  UC-5: Template Management Dashboard
  - Status-Filter (ALL, DRAFT, SUBMITTED, APPROVED, REJECTED)
  - Status-√úberg√§nge mit Validierung
  - Duplikation von APPROVED Templates
  - Re-Upload f√ºr DRAFT Templates
  - Kein User-Management (vereinachte Version)
end note

@enduml
----

=== Stufen√ºbergabe (workbench ‚Üí proof ‚Üí production)

*Szenario:* Template durchl√§uft den kompletten Lebenszyklus von Entwicklung √ºber Pr√ºfung bis zur Produktionsfreigabe

[plantuml, laufzeit-stufenuebergabe, svg]
----
@startuml
actor "Template-Designer" as Designer
actor "Pr√ºfer" as Pruefer
participant "blocpress-workbench\n(Schema: workbench)" as WB
participant "blocpress-proof\n(Schema: proof)" as PR
participant "blocpress-render\n(Schema: production)" as RD

== 1. Entwicklung (workbench) ==

Designer -> WB : Template erstellen\nund bearbeiten
WB -> WB : TF-1: Validierung\nEintr√§ge in Schema: workbench
Designer -> WB : "Zur Pr√ºfung einreichen"

== 2. √úbergabe workbench ‚Üí proof (Kopie) ==

WB -> PR : POST /internal/staging/submit\n(Template-Daten als Kopie)
PR -> PR : INSERT INTO proof.templates\n(Kopie der Daten)
PR --> WB : 201 Created

== 3. Pr√ºfung und Freigabe (proof) ==

Pruefer -> PR : Template pr√ºfen\n(Tests, Review, Freigabe)
PR -> PR : TF-2: Workflow-Pr√ºfung\nVier-Augen-Prinzip
PR -> PR : TF-6: Regressionstests
Pruefer -> PR : "Template freigeben"

== 4. √úbergabe proof ‚Üí production (Kopie) ==

PR -> RD : POST /internal/staging/release\n(Template-Daten als Kopie)
RD -> RD : INSERT INTO production.templates\n(Kopie der Daten, Status: Freigegeben)
RD --> PR : 201 Created

== 5. Produktion ==

note over RD
  Template steht √ºber die
  √∂ffentliche API zur
  Dokumentengenerierung bereit
end note

== Optional: Baseline aus production holen ==

Pruefer -> PR : "Baseline aktualisieren"
PR -> RD : GET /internal/staging/baseline/{id}
RD --> PR : Template-Daten aus production
PR -> PR : UPDATE proof.templates\n(aktuelle Baseline)

@enduml
----

=== Compliance Review-√úberwachung

*Szenario:* Geplanter Job in blocpress-proof pr√ºft t√§glich f√§llige Reviews (TF-7, UC-12)

[plantuml, laufzeit-compliance-check, svg]
----
@startuml
participant "Scheduler\n(Quartz)" as Scheduler
participant "blocpress-proof\nComplianceManager\n(TF-7)" as CM
participant "Repository\n(Schema: proof)" as Repo

Scheduler -> CM : checkReviews()\n(t√§glich 06:00 Uhr)
CM -> Repo : findAllApprovedTemplates()
Repo --> CM : List<Template>

loop f√ºr jedes Template
  CM -> Repo : findLatestReview(templateId)
  Repo --> CM : ComplianceReview (oder null)

  alt kein Review existiert ODER letztes Review abgeschlossen
    CM -> CM : calculateNextReviewDate()\nbasierend auf Review-Zyklus\n(1, 3 oder 5 Jahre)

    alt nextReviewDate <= heute + 30 Tage
      CM -> Repo : createReview(templateId,\ntype, dueDate, status: "Anstehend")
      Repo --> CM : ReviewId
    end
  end
end

CM -> Repo : findOverdueReviews()
Repo --> CM : List<ComplianceReview>

loop f√ºr jedes √ºberf√§llige Review
  CM -> Repo : updateStatus(reviewId, "√úberf√§llig")
end

note right of CM
  TF-7: Compliance-Reviews √ºberpr√ºfen
  L√§uft in blocpress-proof
  Schema: proof
  F√§llige Reviews auf bp-proof UI sichtbar
end note
@enduml
----

<<<<
[[section-deployment-view]]
== Verteilungssicht

_Systemarchitektur und Hardware-Elemente: xref:System_Design_Concept.adoc#sydc-architecture[System Architecture im System Design Concept]_

=== Infrastruktur Ebene 1 (Docker-Compose)

[plantuml, deployment-docker-compose, svg]
----
@startuml
!define RECTANGLE class

skinparam componentStyle rectangle

node "Docker Host" {
  node "blocpress-studio Container" {
    component "Quarkus App\n+ statische Assets\n(HTML/JS/Dynamic Import)" as Studio
  }

  node "blocpress-workbench Container" {
    component "Quarkus App\n(workbench)" as WB
    component "LibreOffice\nheadless ‚â• 24" as LOWB
  }

  node "blocpress-proof Container" {
    component "Quarkus App\n(proof)" as PR
  }

  node "blocpress-render Container" {
    component "Quarkus App\n(render)" as RD
    component "LibreOffice\nheadless ‚â• 24" as LORD
  }

  node "blocpress-admin Container" {
    component "Quarkus App\n(admin)" as AD
  }

  node "postgresql Container" {
    database "PostgreSQL ‚â• 18\n(Schemata: workbench,\nproof, production, admin)" as DB
  }

  node "rabbitmq Container" {
    queue "RabbitMQ" as MQ
  }

  node "elasticsearch Container" {
    component "Elasticsearch ‚â• 7.x" as ES
  }
}

Studio -down-> WB : REST (intern)
Studio -down-> PR : REST (intern)
Studio -down-> AD : REST (intern)

WB -down-> DB : JDBC (workbench)
PR -down-> DB : JDBC (proof)
RD -down-> DB : JDBC (production)
AD -down-> DB : JDBC (admin)

WB -right-> MQ : AMQP
WB -down-> ES : HTTP
WB ..> RD : REST (intern, Vorschau)
PR ..> RD : REST (intern, Test)

note right of DB
  Volumes:
  - /var/lib/postgresql/data
  4 Schemata:
  - workbench, proof,
    production, admin
end note
@enduml
----

*Deployment-Konfiguration (docker-compose.yml):*

[source,yaml]
----
version: '3.8'
services:
  postgresql:
    image: postgres:18-alpine
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      POSTGRES_DB: blocpress
      POSTGRES_USER: blocpress
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    ports:
      - "5432:5432"

  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "5672:5672"
      - "15672:15672"

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
    environment:
      - discovery.type=single-node
      - ES_JAVA_OPTS=-Xms512m -Xmx512m
    ports:
      - "9200:9200"

  blocpress-studio:
    build: ./blocpress-studio
    ports:
      - "8082:8082"
    depends_on:
      - blocpress-workbench
      - blocpress-proof
      - blocpress-admin

  blocpress-workbench:
    build: ./blocpress-workbench
    depends_on:
      - postgresql
      - rabbitmq
      - elasticsearch
    environment:
      QUARKUS_DATASOURCE_JDBC_URL: jdbc:postgresql://postgresql:5432/blocpress?currentSchema=workbench
      RABBITMQ_HOST: rabbitmq
      ELASTICSEARCH_URL: http://elasticsearch:9200
      LIBREOFFICE_HOME: /usr/lib/libreoffice
      BLOCPRESS_RENDER_URL: http://blocpress-render:8083
      # OpenTelemetry (optional)
      # QUARKUS_OTEL_EXPORTER_OTLP_ENDPOINT: http://otel-collector:4317
    ports:
      - "8081:8081"

  blocpress-proof:
    build: ./blocpress-proof
    depends_on:
      - postgresql
    environment:
      QUARKUS_DATASOURCE_JDBC_URL: jdbc:postgresql://postgresql:5432/blocpress?currentSchema=proof
      BLOCPRESS_RENDER_URL: http://blocpress-render:8083
      # QUARKUS_OTEL_EXPORTER_OTLP_ENDPOINT: http://otel-collector:4317
    ports:
      - "8082:8082"

  blocpress-render:
    build: ./blocpress-render
    depends_on:
      - postgresql
    environment:
      QUARKUS_DATASOURCE_JDBC_URL: jdbc:postgresql://postgresql:5432/blocpress?currentSchema=production
      LIBREOFFICE_HOME: /usr/lib/libreoffice
      # QUARKUS_OTEL_EXPORTER_OTLP_ENDPOINT: http://otel-collector:4317
    ports:
      - "8083:8083"
    volumes:
      - libreoffice_cache:/tmp/libreoffice

  blocpress-admin:
    build: ./blocpress-admin
    depends_on:
      - postgresql
    environment:
      QUARKUS_DATASOURCE_JDBC_URL: jdbc:postgresql://postgresql:5432/blocpress?currentSchema=admin
      # QUARKUS_OTEL_EXPORTER_OTLP_ENDPOINT: http://otel-collector:4317
    ports:
      - "8084:8084"

volumes:
  postgres_data:
  libreoffice_cache:
----

=== Infrastruktur Ebene 2 (Kubernetes - Produktiv)

[plantuml, deployment-kubernetes, svg]
----
@startuml
!define RECTANGLE class

skinparam componentStyle rectangle

cloud "Kubernetes Cluster" {
  node "Namespace: blocpress-prod" {
    rectangle "Deployment: blocpress-studio" {
      component "Pod\nstudio (Quarkus)" as StudioPod
    }

    rectangle "Deployment: blocpress-workbench" {
      component "Pod\nworkbench" as WBPod
    }

    rectangle "Deployment: blocpress-proof" {
      component "Pod\nproof" as PRPod
    }

    rectangle "Deployment: blocpress-render" {
      component "Pod 1\nrender" as RDPod1
      component "Pod 2\nrender" as RDPod2
      component "Pod 3\nrender" as RDPod3
    }

    rectangle "Deployment: blocpress-admin" {
      component "Pod\nadmin" as ADPod
    }

    component "Service:\nrender-svc" as RenderSvc

    rectangle "StatefulSet: postgresql" {
      database "PostgreSQL\nPrimary" as DBPrimary
      database "PostgreSQL\nReplica" as DBReplica
    }

    component "Service:\npostgresql-svc" as DBSvc

    rectangle "Deployment: rabbitmq" {
      queue "RabbitMQ" as MQ
    }

    rectangle "StatefulSet: elasticsearch" {
      component "ES Node 1" as ES1
      component "ES Node 2" as ES2
    }

    component "Ingress\nController" as Ingress

    component "PersistentVolume\nClaim: postgres-pvc" as PVC
  }
}

WBPod -down-> DBSvc : JDBC (workbench)
PRPod -down-> DBSvc : JDBC (proof)
RDPod1 -down-> DBSvc : JDBC (production)
RDPod2 -down-> DBSvc : JDBC (production)
RDPod3 -down-> DBSvc : JDBC (production)
ADPod -down-> DBSvc : JDBC (admin)
DBSvc -down-> DBPrimary
DBSvc -down-> DBReplica
DBPrimary -down-> PVC

WBPod -right-> MQ : AMQP
WBPod -down-> ES1 : HTTP

Ingress -down-> StudioPod : HTTP (UI)
Ingress -down-> RenderSvc : HTTP (API)
RenderSvc -down-> RDPod1
RenderSvc -down-> RDPod2
RenderSvc -down-> RDPod3

note right of Ingress
  TLS-Terminierung
  / ‚Üí studio (UI)
  /api ‚Üí render-svc (API)
end note

note right of PVC
  Storage Class: SSD
  Size: 100Gi
  4 Schemata in einer DB
end note
@enduml
----

*Kubernetes-Konfiguration (deployment.yaml ‚Äî Beispiel blocpress-render):*

[source,yaml]
----
apiVersion: apps/v1
kind: Deployment
metadata:
  name: blocpress-render
  namespace: blocpress-prod
spec:
  replicas: 3
  selector:
    matchLabels:
      app: blocpress-render
  template:
    metadata:
      labels:
        app: blocpress-render
    spec:
      containers:
      - name: blocpress-render
        image: blocpress/render:1.0.0
        ports:
        - containerPort: 8083
        env:
        - name: QUARKUS_DATASOURCE_JDBC_URL
          value: jdbc:postgresql://postgresql-svc:5432/blocpress?currentSchema=production
        - name: LIBREOFFICE_HOME
          value: /usr/lib/libreoffice
        # OpenTelemetry (optional)
        # - name: QUARKUS_OTEL_EXPORTER_OTLP_ENDPOINT
        #   value: http://otel-collector-svc:4317
        resources:
          requests:
            memory: "2Gi"
            cpu: "1"
          limits:
            memory: "4Gi"
            cpu: "2"
        livenessProbe:
          httpGet:
            path: /q/health/live
            port: 8083
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /q/health/ready
            port: 8083
          initialDelaySeconds: 10
          periodSeconds: 5
----

NOTE: Die √ºbrigen SCS-Module (workbench, proof, admin) werden analog konfiguriert, jeweils mit eigenem Schema und Port. blocpress-render ist das einzige Modul mit mehreren Replicas, da es die lastintensive Dokumentengenerierung √ºbernimmt.

*Qualit√§tsmerkmale der Verteilungssicht:*

* *Skalierbarkeit:* blocpress-render separat skalierbar (3+ Replicas), √ºbrige Module mit 1 Replica
* *Verf√ºgbarkeit:* PostgreSQL mit Primary-Replica-Setup, Elasticsearch mit 2 Nodes
* *Performance:* SSD-Storage f√ºr PostgreSQL, Connection Pooling pro Modul, Load Balancing f√ºr render
* *√úberwachbarkeit:* Liveness-/Readiness-Probes je Modul, OpenTelemetry f√ºr Traces/Metriken/Logs (optional)
* *Unabh√§ngigkeit:* Jedes SCS-Modul kann unabh√§ngig deployed und aktualisiert werden

<<<<
[[section-concepts]]
== Querschnittliche Konzepte

_Detaillierte Entities: xref:Element_Design_Concept.adoc#edc-entities[Entities im Element Design Concept] | Gesch√§ftsentit√§ten: xref:Solution_Design_Concept.adoc#sdc-ia[Information Architecture im Solution Design Concept]_

=== Dom√§nenmodell

[plantuml, domain-model, svg]
----
@startuml
!define ENTITY class

package "Schema: workbench" #LightBlue {
  ENTITY "Template\n(Entwurf)" as TWB {
    + id: Long
    + name: String
    + version: Integer
    + status: String
    + template_binary: bytea
    + user_fields: JSONB
  }

  ENTITY Baustein {
    + id: Long
    + name: String
    + typ: String
    + inhalt: bytea
  }
}

package "Schema: proof" #LightGreen {
  ENTITY "Template\n(Pr√ºfung)" as TPR {
    + id: Long
    + name: String
    + version: Integer
    + status: String
    + template_binary: bytea
    + review_zyklus: Integer
  }

  ENTITY Freigabeprozess {
    + id: Long
    + workflow_status: String
    + pruefer_id: Long
  }

  ENTITY ComplianceReview {
    + id: Long
    + review_typ: String
    + faelligkeitsdatum: Date
    + review_status: String
  }

  ENTITY TestCase {
    + id: Long
    + test_name: String
    + json_testdaten: JSONB
    + erwartetes_pdf: bytea
  }
}

package "Schema: production" #LightYellow {
  ENTITY "Template\n(Freigegeben)" as TPROD {
    + id: Long
    + name: String
    + version: Integer
    + status: String = "Freigegeben"
    + template_binary: bytea
  }

  ENTITY Dokumentengenerierung {
    + id: Long
    + json_daten: JSONB
    + output_format: String
    + generiertes_dokument: bytea
    + status: String
  }
}

package "Schema: admin" #LightCoral {
  ENTITY Benutzer {
    + id: Long
    + name: String
    + email: String
    + rollen: JSONB
  }

  ENTITY AuditLog {
    + id: Long
    + user_id: Long
    + aktion: String
    + zeitstempel: Timestamp
  }
}

TWB "0..*" -- "0..*" Baustein : verwendet >
TPR "1" -- "0..*" Freigabeprozess : hat >
TPR "1" -- "0..*" ComplianceReview : unterliegt >
TPR "1" -- "0..*" TestCase : wird getestet durch >
TPROD "1" -- "0..*" Dokumentengenerierung : erzeugt >

TWB -right[dashed]-> TPR : Kopie\n(√úbergabe)
TPR -right[dashed]-> TPROD : Kopie\n(Freigabe)
@enduml
----

NOTE: Die Template-Tabelle existiert mit identischer Struktur in allen drei fachlichen Schemata (workbench, proof, production). Die Stufen√ºbergabe erfolgt als Datenkopie zwischen den Schemata.

=== Benutzerverwaltung und Sicherheit

*Authentifizierung (JWT-basiert):*

* blocpress-studio (Portal-Shell) √ºbernimmt die Authentifizierung und h√§lt das JWT
* Jedes SCS-Modul validiert JWTs eigenst√§ndig via Quarkus SmallRye JWT Extension
* JWT wird von der Studio-Shell als Property an die Web Components weitergereicht: `<bp-workbench jwt="${token}"></bp-workbench>`
* Web Components senden das JWT als `Authorization: Bearer` Header bei REST-Aufrufen an ihr Backend
* Issuer und Public Key werden in jeder `application.properties` konfiguriert (`mp.jwt.verify.issuer`, `mp.jwt.verify.publickey.location`)
* Kompatibel mit jedem IdP, der JWTs ausstellt ‚Äî nur Public Key und Issuer m√ºssen konfiguriert werden

*Autorisierung:*

Rollenbasierte Zugriffskontrolle (RBAC) ‚Äî konsolidierte Rollen:

[cols="2,3,3" options="header"]
|===
| Rolle | Berechtigungen | SCS-Modul / Use Cases

| Template-Designer
| Template erstellen, bearbeiten, einreichen, Bausteine verwalten, Suche
| blocpress-workbench: UC-1 bis UC-5, UC-19 bis UC-21

| Pr√ºfer (QM / Freigeber / Compliance)
| Templates pr√ºfen, freigeben/ablehnen, Compliance-Reviews durchf√ºhren, Tests verwalten und ausf√ºhren
| blocpress-proof: UC-6 bis UC-9, UC-11 bis UC-18

| Administrator
| Benutzer verwalten, Rollen zuweisen, System konfigurieren
| blocpress-admin: UC-22 bis UC-24

| API-Konsument
| Dokumente generieren (nur via √∂ffentliche API)
| blocpress-render: POST /api/documents/generate
|===

*Sicherheitskonzepte:*

* *Vier-Augen-Prinzip:* Technisch erzwungen in TF-2 (blocpress-proof): `userId != template.erstellerId`
* *HTTPS/TLS:* Alle externen Verbindungen verschl√ºsselt
* *JWT-Weitergabe:* √úber Web Component Properties ‚Äî kein LocalStorage, kein Cookie
* *Schema-Isolation:* Jedes SCS-Modul hat nur Zugriff auf sein eigenes Datenbank-Schema
* *SQL-Injection-Schutz:* Prepared Statements, JPA/Hibernate
* *DSGVO-Compliance:* L√∂schfunktion f√ºr personenbezogene Daten in E-3, E-6

=== Persistenz und Storage

*Multi-Schema-Architektur:*

Alle SCS-Module teilen sich eine PostgreSQL-Instanz, nutzen aber jeweils ein eigenes Schema:

[cols="1,2,2" options="header"]
|===
| Schema | SCS-Modul | Enthaltene Entities

| `workbench`
| blocpress-workbench
| Template (Entwurf), Baustein, Template-Baustein-Zuordnung

| `proof`
| blocpress-proof
| Template (Pr√ºfung), Freigabeprozess, ComplianceReview, TestCase, Testpool

| `production`
| blocpress-render
| Template (Freigegeben), Dokumentengenerierung

| `admin`
| blocpress-admin
| Benutzer, AuditLog
|===

Die Template-Tabelle hat in allen drei fachlichen Schemata eine identische Struktur. Dies erm√∂glicht die kopie-basierte Stufen√ºbergabe: `INSERT INTO proof.templates SELECT ... FROM workbench.templates WHERE id = ?`.

*Storage Abstraction Layer:*

[source,java]
----
public interface StorageService {
    StorageId save(byte[] data, String key);
    byte[] load(StorageId id);
    void delete(StorageId id);
}
----

Jedes SCS-Modul nutzt eine eigene `StorageService`-Instanz, die auf das jeweilige Schema zugreift.

*Datenbank-Schema (Auszug ‚Äî Schema: workbench):*

[source,sql]
----
CREATE SCHEMA workbench;

CREATE TABLE workbench.templates (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    version INTEGER NOT NULL,
    status VARCHAR(50) NOT NULL,
    ersteller_id BIGINT,         -- Referenz auf admin.benutzer (JWT sub)
    template_binary BYTEA,
    user_fields JSONB,
    review_zyklus INTEGER,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Identische Struktur in proof und production:
-- CREATE SCHEMA proof;
-- CREATE TABLE proof.templates (...);
-- CREATE SCHEMA production;
-- CREATE TABLE production.templates (...);
----

*Schema-Konfiguration pro Modul:*

[source,properties]
----
# blocpress-workbench
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/blocpress?currentSchema=workbench

# blocpress-proof
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/blocpress?currentSchema=proof

# blocpress-render
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/blocpress?currentSchema=production
----

*Transaktionsmanagement:*

* JTA-Transaktionen f√ºr atomare Operationen innerhalb eines Schemas
* Stufen√ºbergabe (Cross-Schema-Kopie) erfolgt √ºber interne REST-APIs, nicht √ºber Cross-Schema-SQL
* Isolation Level: READ_COMMITTED
* Rollback bei Fehlern in Use Cases

=== Micro-Frontend-Architektur (Web Components)

blocpress-studio ist die Portal-Shell, die Micro-Frontends der SCS-Module als Web Components integriert.

*Prinzip:*

* Jedes SCS-Modul liefert ein JavaScript-Bundle mit Custom Elements (z.B. `<bp-workbench>`, `<bp-proof>`, `<bp-admin>`)
* Die Web Components nutzen Shadow DOM f√ºr vollst√§ndige CSS- und DOM-Kapselung
* Studio l√§dt die Bundles dynamisch via Dynamic Import (`import()`) von den jeweiligen SCS-Modulen

*Dynamic Import (Beispiel):*

[source,html]
----
// Studio l√§dt Web Components per Dynamic Import von den SCS-Modulen
async function loadWorkbench() {
  const workbenchUrl = 'http://localhost:8081'; // konfigurierbar
  await import(`${workbenchUrl}/components/bp-workbench.js`);
}
----

*JWT-Weitergabe:*

[source,html]
----
<!-- Studio-Shell: JWT als Property an Web Component -->
<bp-workbench jwt="${currentUser.token}"></bp-workbench>
----

[source,javascript]
----
// Web Component: JWT empfangen und f√ºr REST-Aufrufe verwenden
class BpWorkbench extends HTMLElement {
  static get observedAttributes() { return ['jwt']; }

  attributeChangedCallback(name, oldVal, newVal) {
    if (name === 'jwt') this._jwt = newVal;
  }

  async fetchTemplates() {
    const res = await fetch('/api/workbench/templates', {
      headers: { 'Authorization': `Bearer ${this._jwt}` }
    });
    // ...
  }
}
customElements.define('bp-workbench', BpWorkbench);
----

*Vorteile:*

* Vollst√§ndige UI-Isolation: CSS und DOM eines Moduls beeinflussen andere Module nicht
* Unabh√§ngiges Deployment: Web Component-Bundles k√∂nnen einzeln aktualisiert werden
* Framework-Freiheit: Jedes Modul kann intern ein beliebiges UI-Framework verwenden
* JWT-Sicherheit: Token wird als Property √ºbergeben, nicht im LocalStorage

=== Template-Verarbeitung mit LibreOffice

*LibreOffice-Integration:*

[source,java]
----
public class LibreOfficeProcessor {
    private XComponentLoader componentLoader;

    public ValidationResult validateTemplate(byte[] odtBinary) {
        // 1. Lade ODT √ºber LibreOffice UNO-API
        XComponent doc = componentLoader.loadComponentFromURL(...);

        // 2. Extrahiere User-Fields
        XTextFieldsSupplier fieldsSupplier = (XTextFieldsSupplier) doc;
        XNameAccess fields = fieldsSupplier.getTextFields();

        // 3. Identifiziere Wiederholungsgruppen (Sections/Tables)
        XTextSectionsSupplier sectionsSupplier = (XTextSectionsSupplier) doc;

        // 4. Validiere Punkt-Notation in Field-Namen
        // z.B. "kunde.name" ist valide, "kunde name" ist invalide

        return new ValidationResult(...);
    }

    public byte[] generateDocument(Template template,
                                   String jsonData,
                                   OutputFormat format) {
        // 1. Parse JSON zu Map/Object
        JsonNode json = objectMapper.readTree(jsonData);

        // 2. √ñffne Template
        XComponent doc = loadTemplate(template.getTemplateBinary());

        // 3. Bef√ºlle User-Fields
        for (UserField field : template.getUserFields()) {
            String value = resolveJsonPath(json, field.getName());
            setFieldValue(doc, field.getName(), value);
        }

        // 4. Iteriere Wiederholungsgruppen
        for (RepetitionGroup group : template.getRepetitionGroups()) {
            JsonNode array = resolveJsonPath(json, group.getArrayRef());
            duplicateAndFillGroup(doc, group, array);
        }

        // 5. Evaluiere IF-Bedingungen
        evaluateConditions(doc, json);

        // 6. Exportiere
        return exportDocument(doc, format); // ODT/PDF/RTF
    }
}
----

*Determinismus:*

* Keine Zufallswerte, keine Zeitstempel in Template-Verarbeitung
* Sortierung von Arrays im JSON konsistent (z.B. nach ID)
* LibreOffice-Version fixiert (‚â• 24)
* Gleiche Template-Bin√§rdaten + gleiche JSON-Daten = gleiches Ausgabedokument

=== Asynchrone Verarbeitung

*Message Queue Pattern:*

[source,java]
----
// Producer (UC-10: Testdokument generieren)
public class DocumentService {
    @Inject
    MqttClient mqttClient;

    public GenerationId generateDocument(UUID templateId,
                                         String jsonData,
                                         OutputFormat format) {
        // 1. Erstelle Generierungs-Record
        Dokumentengenerierung gen = new Dokumentengenerierung();
        gen.setStatus("In Bearbeitung");
        repository.save(gen);

        // 2. Sende Message an Queue
        GenerationMessage msg = new GenerationMessage(
            gen.getId(), templateId, jsonData, format);
        mqttClient.send("document.generation", msg);

        return gen.getId();
    }
}

// Consumer (Worker)
@ApplicationScoped
public class DocumentWorker {
    @Inject
    LibreOfficeProcessor processor;

    @Incoming("document.generation")
    public void processGeneration(GenerationMessage msg) {
        try {
            Template template = loadTemplate(msg.getTemplateId());
            byte[] doc = processor.generateDocument(
                template, msg.getJsonData(), msg.getFormat());

            storageService.save(doc, ...);
            updateStatus(msg.getGenerationId(), "Erfolgreich");
        } catch (Exception e) {
            updateStatus(msg.getGenerationId(), "Fehlgeschlagen");
            log.error("Generation failed", e);
        }
    }
}
----

*Vorteile:*

* Nicht-blockierend: API gibt sofort GenerationId zur√ºck
* Skalierbar: Worker-Pool kann unabh√§ngig skaliert werden
* Fehlertoleranz: Retry-Mechanismus bei Fehlern
* Entkopplung: Producer und Consumer unabh√§ngig deploybar

=== Observability (OpenTelemetry)

Alle SCS-Module nutzen *Quarkus OpenTelemetry* (`quarkus-opentelemetry`) f√ºr die Erfassung von Traces, Metriken und Logs. Die Integration ist vendor-neutral und erfordert vom Betreiber lediglich die Konfiguration eines OTLP-Endpunkts.

*Auto-Instrumentation:*

Quarkus instrumentiert automatisch:

* REST-API-Aufrufe (Eingangs-Requests und ausgehende HTTP-Calls)
* JDBC-Datenbankzugriffe (PostgreSQL)
* Message-Queue-Operationen (RabbitMQ/Kafka)

F√ºr diese Standardmetriken und Traces ist kein eigener Code erforderlich.

*Konfiguration:*

[source,properties]
----
# OpenTelemetry aktivieren (optional ‚Äî ohne Endpoint werden keine Daten exportiert)
quarkus.otel.exporter.otlp.endpoint=http://otel-collector:4317

# Service-Name f√ºr Traces und Metriken
quarkus.otel.resource.attributes=service.name=blocpress-workbench  # bzw. -proof, -render, -admin

# Logging: Standard Quarkus JSON-Logging, wird durch OTel-Kontext (Trace-ID, Span-ID) angereichert
quarkus.log.console.format=%d{yyyy-MM-dd HH:mm:ss} %-5p traceId=%X{traceId} [%c] %s%e%n
----

*Optionalit√§t:*

Wird kein `quarkus.otel.exporter.otlp.endpoint` konfiguriert, ist OpenTelemetry deaktiviert ‚Äî die SCS-Module laufen ohne externe Monitoring-Abh√§ngigkeit. Der Betreiber kann jeden OTLP-kompatiblen Collector einsetzen (z.B. Grafana Alloy, Jaeger, Datadog Agent).

*Audit-Logging:*

Audit-Logging f√ºr Compliance-relevante Aktionen (Freigaben, Reviews, Status√§nderungen) ist ein eigenst√§ndiges Konzept und unabh√§ngig von OpenTelemetry. Audit-Eintr√§ge werden in einer separaten, nicht modifizierbaren Datenbanktabelle gespeichert (User-ID, Zeitstempel, Aktion, alte/neue Werte).

*Health-Checks:*

Quarkus stellt Liveness- und Readiness-Probes automatisch bereit (`/q/health/live`, `/q/health/ready`). Diese sind unabh√§ngig von OpenTelemetry und erfordern keine zus√§tzliche Konfiguration.

<<<<
[[section-design-decisions]]
== Architekturentscheidungen

_Zugeh√∂rige Constraints: xref:Element_Design_Concept.adoc#edc-constraints[Constraints im Element Design Concept] | xref:System_Design_Concept.adoc#sydc-constraints[Constraints im System Design Concept]_

=== ADR-001: Bin√§rdaten in PostgreSQL statt S3

*Status:* Akzeptiert

*Kontext:*

Wir m√ºssen entscheiden, wo Template-Bin√§rdaten (ODT), generierte Dokumente (PDF/RTF) und Test-Baselines (PDF) gespeichert werden. Optionen: PostgreSQL (bytea) oder S3-kompatibler Object Storage.

*Entscheidung:*

Speicherung in PostgreSQL bytea-Spalten. Erwartetes Datenvolumen: < 5.000 Dokumente + Templates.

*Begr√ºndung:*

* *Einfachheit:* Keine zus√§tzliche Infrastruktur-Komponente
* *Transaktionalit√§t:* Metadaten + Bin√§rdaten in einer Transaktion
* *Performance:* Bei < 5.000 Dokumenten ist PostgreSQL performant genug
* *Kosteneffizienz:* Kein separater S3-Service notwendig
* *Zukunftssicherheit:* Storage Abstraction Layer erm√∂glicht sp√§teren Wechsel zu S3

*Konsequenzen:*

* Positiv: Einfacheres Deployment, weniger Moving Parts, ACID-Garantien
* Negativ: PostgreSQL-Backup gr√∂√üer, bei > 5.000 Dokumenten Migration zu S3 notwendig
* Mitigation: Storage Abstraction Layer implementiert, Migration zu S3 vorbereitet

=== ADR-002: Quarkus statt Spring Boot

*Status:* Akzeptiert

*Kontext:*

Wahl des Java-Frameworks f√ºr die SCS-Module. Optionen: Spring Boot, Quarkus, Micronaut.

*Entscheidung:*

Quarkus Framework

*Begr√ºndung:*

* *Performance:* Schnellere Startup-Zeit (< 1s vs. 5-10s bei Spring Boot)
* *Memory-Footprint:* Geringerer RAM-Verbrauch (wichtig bei Container-Deployment)
* *Cloud-Native:* Entwickelt f√ºr Kubernetes, native Kompilierung m√∂glich (GraalVM)
* *Developer Experience:* Live-Reload, Dev-Services, gute Dokumentation
* *Standards:* Jakarta EE, MicroProfile (nicht vendor-locked)

*Konsequenzen:*

* Positiv: Bessere Container-Performance, niedrigere Infrastruktur-Kosten
* Negativ: Kleineres √ñkosystem als Spring Boot, weniger Extensions

=== ADR-003: Asynchrone Dokumentengenerierung

*Status:* Akzeptiert

*Kontext:*

Dokumentengenerierung kann 5-30 Sekunden dauern. Soll der REST-API-Call blockieren oder asynchron sein?

*Entscheidung:*

Asynchrone Verarbeitung √ºber Message Queue (RabbitMQ/Kafka)

*Begr√ºndung:*

* *Responsiveness:* API gibt sofort (< 100ms) GenerationId zur√ºck
* *Skalierbarkeit:* Worker-Pool kann unabh√§ngig von API-Servern skaliert werden
* *Fehlertoleranz:* Retry-Mechanismus bei LibreOffice-Fehlern
* *Monitoring:* Queue-L√§nge zeigt System-Last

*Konsequenzen:*

* Positiv: Bessere User Experience, horizontal skalierbar
* Negativ: Komplexere Architektur, Client muss pollen oder WebSocket nutzen
* Mitigation: Klares API-Design (202 Accepted, Polling-Endpoint)

=== ADR-004: Elasticsearch f√ºr Content Search

*Status:* Akzeptiert

*Kontext:*

Volltextsuche √ºber alle Templates nach fachlichen Konstrukten. Optionen: PostgreSQL Full-Text-Search, Elasticsearch, Apache Solr.

*Entscheidung:*

Elasticsearch ‚â• 7.x

*Begr√ºndung:*

* *Performance:* Sub-2-Sekunden-Suche auch bei 1.000+ Templates
* *Relevanz:* Besseres Ranking als PostgreSQL FTS
* *Highlighting:* Zeigt Treffer im Kontext
* *Skalierbarkeit:* Horizontal skalierbar (mehrere Nodes)
* *Reife:* Bew√§hrte Technologie, gro√üe Community

*Konsequenzen:*

* Positiv: Exzellente Suchperformance und -qualit√§t
* Negativ: Zus√§tzliche Infrastruktur-Komponente, h√∂here Komplexit√§t
* Risiko: Eventual Consistency (Index kann wenige Sekunden verz√∂gert sein)

=== ADR-005: LibreOffice headless statt Cloud-Conversion-Service

*Status:* Akzeptiert

*Kontext:*

Template-Verarbeitung und Dokumentengenerierung. Optionen: LibreOffice headless (self-hosted), Cloud-Conversion-Service (z.B. Aspose, CloudConvert).

*Entscheidung:*

LibreOffice ‚â• 24 headless, integriert in blocpress-render (Format-Export). blocpress-workbench nutzt blocpress-core f√ºr Validierung ohne LibreOffice

*Begr√ºndung:*

* *Kosteneffizienz:* Keine Lizenzkosten, keine API-Kosten
* *Datenschutz:* Templates verlassen nicht die eigene Infrastruktur
* *Kontrolle:* Vollst√§ndige Kontrolle √ºber Verarbeitungs-Pipeline
* *Determinismus:* LibreOffice-Version fixiert, reproduzierbare Ergebnisse
* *ODT-Support:* Native Unterst√ºtzung f√ºr OpenDocument-Format

*Konsequenzen:*

* Positiv: Keine externe Abh√§ngigkeit, DSGVO-konform, kosteneffizient
* Negativ: LibreOffice-Deployment komplex, Memory-Verbrauch h√∂her
* Risiko: LibreOffice-Bugs, Performance-Tuning notwendig

=== ADR-006: Self-Contained Systems (SCS) statt Monolith

*Status:* Akzeptiert

*Kontext:*

blocpress wurde initial als monolithische Quarkus-Anwendung (blocpress-server) konzipiert. Mit wachsender fachlicher Komplexit√§t (Template-Entwicklung, Pr√ºfung/Freigabe, Compliance, Administration, Dokumentengenerierung) entstehen enge Kopplung und erschwerte Wartbarkeit. Es soll eine Zerlegung in unabh√§ngig wartbare Module erfolgen.

*Entscheidung:*

Zerlegung in f√ºnf Self-Contained Systems (SCS) mit eigener UI, eigenem Backend und eigenem Datenbank-Schema:

* *blocpress-studio* ‚Äî Portal-Shell (Navigation, Auth, Micro-Frontend-Integration)
* *blocpress-workbench* ‚Äî Template-Entwicklung (Dev-Stufe)
* *blocpress-proof* ‚Äî Pr√ºfung, Freigabe, Compliance, Tests (QA-Stufe)
* *blocpress-render* ‚Äî Dokumentengenerierung (Einzige √∂ffentliche API, Production-Stufe)
* *blocpress-admin* ‚Äî Benutzerverwaltung, Systemkonfiguration

Gemeinsame Logik (ODT-Parsing, Validierung, Merge-Pipeline) wird in *blocpress-core* als Shared Java-Library bereitgestellt und von blocpress-workbench und blocpress-render als Maven-Abh√§ngigkeit genutzt.

Drei Datenstufen mit kopie-basierter √úbergabe: workbench ‚Üí proof ‚Üí production.

*Begr√ºndung:*

* *Wartbarkeit:* Jedes Modul kann unabh√§ngig entwickelt, getestet und deployed werden
* *Team-Ownership:* Module k√∂nnen von verschiedenen Teams verantwortet werden
* *Skalierbarkeit:* blocpress-render (lastintensiv) kann separat skaliert werden
* *Fachliche Koh√§sion:* Jedes Modul kapselt einen klar abgegrenzten fachlichen Bereich
* *UI-Isolation:* Web Components mit Shadow DOM verhindern CSS-/DOM-Konflikte

*Konsequenzen:*

* Positiv: Bessere Wartbarkeit, unabh√§ngige Deployments, gezielte Skalierung, klare Ownership
* Negativ: H√∂here Deployment-Komplexit√§t (5 Container statt 1), Datenredundanz durch Kopien, Cross-Schema-Kommunikation √ºber REST statt direkte DB-Zugriffe
* Mitigation: Gemeinsame PostgreSQL-Instanz reduziert Infrastruktur-Overhead, Docker-Compose/Kubernetes-Konfiguration automatisiert Deployment

<<<<
[[section-quality-requirements]]
== Qualit√§tsanforderungen

_Qualit√§tsanforderungen auf Fachebene: xref:Solution_Design_Concept.adoc#sdc-qr[Quality Requirements im Solution Design Concept] | auf Systemebene: xref:System_Design_Concept.adoc#sydc-qr[Quality Requirements im System Design Concept] | auf Elementebene: xref:Element_Design_Concept.adoc#edc-qr[Quality Requirements im Element Design Concept]_

=== Qualit√§tsbaum

[plantuml, quality-tree, svg]
----
@startmindmap
* blocpress\nQualit√§tsanforderungen

** Performance
*** Dokumentengenerierung < 5s\n(Standard-Dokumente)
*** Suche < 2s\n(√ºber alle Templates)
*** API-Latenz < 100ms\n(ohne Generierung)

** Zuverl√§ssigkeit
*** Determinismus\n(gleiche Eingabe = gleiche Ausgabe)
*** Transaktionale Integrit√§t\n(ACID)
*** Fehlertoleranz\n(Retry-Mechanismen)

** Wartbarkeit
*** Storage Abstraction Layer\n(Austauschbarkeit)
*** Versionierung\n(Templates & Code)
*** OpenTelemetry\n(Traces, Metriken, Logs)

** Sicherheit
*** Vier-Augen-Prinzip\n(technisch erzwungen)
*** RBAC\n(rollenbasiert)
*** Rate Limiting\n(1.000 req/h)
*** HTTPS/TLS\n(verschl√ºsselt)

** Skalierbarkeit
*** Horizontal skalierbar\n(Kubernetes)
*** 100 gleichzeitige\nGenerierungen
*** Message Queue\n(Entkopplung)

** Compliance
*** DSGVO\n(L√∂schkonzept)
*** Audit-Logging\n(manipulationssicher)
*** Review-Zyklen\n(1/3/5 Jahre)

@endmindmap
----

=== Qualit√§tsszenarien

[cols="1,2,2,2" options="header"]
|===
| Qualit√§tsziel | Szenario | Stimulus | Response

| *Performance*
| Standard-Dokumentengenerierung
| Externe Anwendung sendet Request mit Template (20 Seiten) und JSON-Daten
| Dokument wird innerhalb von 5 Sekunden generiert und zur√ºckgegeben

| *Performance*
| Volltextsuche
| Template-Designer sucht nach "Beitragsanpassung" (1.000 Templates im Index)
| Suchergebnisse werden innerhalb von 2 Sekunden angezeigt

| *Zuverl√§ssigkeit*
| Deterministische Generierung
| Gleiches Template + gleiche JSON-Daten, zweimal aufgerufen
| Beide generierten PDFs sind Byte-f√ºr-Byte identisch (Regressionstests best√§tigen)

| *Zuverl√§ssigkeit*
| Transaktionale Integrit√§t
| Template-Freigabe schl√§gt fehl (z.B. DB-Fehler nach Status-Update)
| Komplettes Rollback: Template beh√§lt alten Status, kein Freigabeprozess-Eintrag erstellt

| *Wartbarkeit*
| Storage-Austausch
| Migration von PostgreSQL bytea zu S3
| Storage Abstraction Layer erm√∂glicht Implementierungswechsel ohne √Ñnderungen in Use Cases/TFs

| *Wartbarkeit*
| Template-Versionierung
| Template wird ge√§ndert
| Neue Version wird erstellt, alte Version bleibt verf√ºgbar, √Ñnderungen nachvollziehbar

| *Sicherheit*
| Vier-Augen-Prinzip
| Designer versucht, sein eigenes Template freizugeben
| TF-2 verweigert Freigabe mit Fehlermeldung "Designer darf nicht freigeben (Vier-Augen-Prinzip)"

| *Skalierbarkeit*
| Horizontale Skalierung
| 150 gleichzeitige Dokumentengenerierungen
| Kubernetes skaliert auf 5 blocpress-render Pods, Queue puffert Last, alle Requests erfolgreich

| *Skalierbarkeit*
| Message Queue Entkopplung
| 100 Generierungsanfragen in 10 Sekunden
| API nimmt alle Anfragen an (< 100ms Response), Queue verarbeitet asynchron

| *Compliance*
| DSGVO-L√∂schung
| Administrator l√∂scht personenbezogene Daten in Test Cases
| JSON-Testdaten werden aus E-6 entfernt, Test-PDFs anonymisiert oder gel√∂scht

| *Compliance*
| Turnusm√§√üiges Review
| Template mit 3-Jahres-Zyklus ist seit 3 Jahren freigegeben
| Compliance Manager erstellt automatisch Review-Aufgabe, f√§lliges Review ist auf UI-3 sichtbar

| *Benutzbarkeit*
| Template-Upload mit Validierung
| Designer l√§dt Template mit ung√ºltigen User-Fields hoch
| System zeigt klare Validierungsfehler ("Field 'kunde name' enth√§lt Leerzeichen, Punkt-Notation erforderlich")

| *√úbertragbarkeit*
| Docker-Deployment
| blocpress soll in neuer Umgebung deployed werden
| docker-compose up startet alle Services, keine manuellen Konfigurationsschritte
|===

<<<<
[[section-risks-and-technical-debt]]
== Risiken und technische Schulden

=== Risiken

[cols="1,2,1,2,2" options="header"]
|===
| ID | Risiko | Wahrscheinlichkeit | Auswirkung | Ma√ünahme

| R-1
| *LibreOffice Memory Leaks*: LibreOffice headless kann bei Langzeitbetrieb Memory Leaks entwickeln
| Mittel
| Hoch (Out-of-Memory, Systemausfall)
| - Regelm√§√üiger Neustart von LibreOffice-Instanzen nach X Generierungen
- Memory-Monitoring
- Container-Restart bei Memory-Limit

| R-2
| *PostgreSQL bytea Performance*: Bei > 5.000 Dokumenten kann Performance von PostgreSQL bytea degradieren
| Hoch
| Mittel (Langsamere Queries)
| - Storage Abstraction Layer bereits implementiert
- Migration zu S3 vorbereitet
- Monitoring der DB-Performance

| R-3
| *Determinismus-Verlust*: LibreOffice-Updates k√∂nnen Rendering √§ndern, Determinismus brechen
| Mittel
| Hoch (Regressionstests schlagen fehl)
| - LibreOffice-Version in Dockerfile fixieren
- Regressionstests bei jedem LibreOffice-Update
- Baseline-PDFs bei bewusstem Update neu generieren

| R-4
| *Message Queue Single Point of Failure*: Wenn RabbitMQ ausf√§llt, keine asynchrone Verarbeitung m√∂glich
| Niedrig
| Hoch (Keine Dokumentengenerierung)
| - RabbitMQ Cluster (3 Nodes)
- Persistent Messages
- Monitoring & Alerting

| R-5
| *Elasticsearch Eventual Consistency*: Index kann wenige Sekunden verz√∂gert sein
| Hoch
| Niedrig (Nutzer findet neu hochgeladenes Template nicht sofort)
| - User informieren ("Index wird aktualisiert, Template erscheint in ca. 10 Sekunden")
- Refresh-Button in UI

| R-6
| *Compliance Review-Backlog*: Viele Templates werden gleichzeitig f√§llig
| Mittel
| Mittel (Compliance-Reviewer √ºberlastet)
| - Fr√ºhwarnung (30 Tage im Voraus)
- Priorisierung nach Kritikalit√§t
- Eskalation bei √úberschreitung

| R-7
| *LibreOffice-API Breaking Changes*: LibreOffice-Updates k√∂nnen UNO-API √§ndern
| Niedrig
| Hoch (Code-Anpassungen notwendig)
| - Versionsfixierung
- Umfassende Integration-Tests
- Update-Strategie dokumentiert
|===

=== Technische Schulden

[cols="1,2,2,2" options="header"]
|===
| ID | Technische Schuld | Auswirkung | Refactoring-Plan

| TD-1
| *Fehlende Caching-Strategie*: Templates werden bei jeder Generierung aus DB geladen
| Performance: Unn√∂tige DB-Last, langsamere Generierung
| - Caffeine Cache f√ºr Templates implementieren
- Cache-Invalidierung bei Template-Update
- TTL: 1 Stunde

| TD-2
| *Keine Batch-Generierung*: API unterst√ºtzt nur Single-Document-Generation
| Effizienz: Viele API-Calls f√ºr Batch-Szenarien
| - Batch-Endpoint hinzuf√ºgen: `POST /api/documents/batch`
- Array von Generierungs-Requests
- Transaktional verarbeiten

| TD-3
| *Hartcodierte LibreOffice-Pfade*: LibreOffice-Installation fest in Code
| Wartbarkeit: Erschwert Deployment in verschiedenen Umgebungen
| - Pfad als Environment-Variable
- Auto-Detection von LibreOffice
- Fallback-Mechanismus

| TD-4
| *Fehlende WebSocket-Unterst√ºtzung*: Client muss f√ºr Generierungs-Status pollen
| Benutzbarkeit: H√∂here Last, langsameres Feedback
| - WebSocket-Endpoint f√ºr Status-Updates
- Server-Sent Events (SSE) als Alternative
| Geplant f√ºr Release 2.0

| TD-5
| *Kein PDF-Differenz-Highlighting*: TF-6 gibt nur Text-Unterschiede zur√ºck
| Testbarkeit: Test-Manager muss Unterschiede manuell finden
| - PDF-Differenz visuell markieren (z.B. rote Umrandung)
- Screenshot-Diff als Zusatzfeature
| Geplant f√ºr Release 1.5

| TD-6
| *Fehlende Template-Preview*: Nutzer sehen Template erst nach Download
| Benutzbarkeit: Umst√§ndlicher Workflow
| - Template-Preview in Web-UI (PDF-Rendering)
- Thumbnail-Generierung
| Nice-to-have

| TD-7
| *Keine Versionsverwaltung f√ºr Bausteine*: Bausteine haben Version, aber keine Historie
| Wartbarkeit: √Ñnderungen an Bausteinen nicht nachvollziehbar
| - Baustein-Versionierung wie bei Templates
- Historie-View in UI
| Geplant f√ºr Release 2.0
|===

<<<<
[[section-glossary]]
== Glossar

[cols="1,3" options="header"]
|===
| Begriff | Definition

| *Baustein*
| Wiederverwendbares LibreOffice-Fragment (ODT), das in mehreren Templates eingebunden werden kann (z.B. Standardfu√üzeile, AGBs). Verwaltet in blocpress-workbench. Entity E-2.

| *Baseline-PDF*
| Erwartetes PDF-Ergebnis eines Test Cases, gegen das aktuelle Generierungen verglichen werden. Verwaltet in blocpress-proof.

| *blocpress-admin*
| SCS-Modul f√ºr Administration: Benutzerverwaltung, Rollenzuweisung, Systemkonfiguration, Audit-Logs. Schema: `admin`.

| *blocpress-core*
| Shared Java-Library (Maven-Abh√§ngigkeit, kein eigenst√§ndiger Container): ODT-Parsing (odfdom), Template-Validierung, Merge-Pipeline (Text-Block-Expansion, Bedingungen, Schleifen, Feldersetzung). Wird von blocpress-workbench (Validierung) und blocpress-render (Merge + Generierung) genutzt. Keine LibreOffice-Abh√§ngigkeit.

| *blocpress-proof*
| SCS-Modul f√ºr Pr√ºfung und Freigabe: Workflow, Compliance-Reviews, Testdaten, Regressionstests. Arbeitsumgebung des Pr√ºfers. Schema: `proof`.

| *blocpress-render*
| SCS-Modul f√ºr Dokumentengenerierung: Einzige √∂ffentliche REST-API. Liest freigegebene Templates aus dem production-Schema. Stateless, horizontal skalierbar.

| *blocpress-studio*
| Portal-Shell (Quarkus): Keine eigene Business-Logik. Verantwortlich f√ºr Navigation, JWT-Authentifizierung und Integration der Micro-Frontends (Web Components) via Dynamic Import.

| *blocpress-workbench*
| SCS-Modul f√ºr Template-Entwicklung: Upload, Validierung, Bearbeitung, Bausteinverwaltung, Content Search. Arbeitsumgebung des Template-Designers. Schema: `workbench`.

| *Compliance Review*
| Turnusm√§√üige Pr√ºfung eines Templates auf inhaltliche Aktualit√§t. Review-Zyklen: 1, 3 oder 5 Jahre. Verwaltet in blocpress-proof. Entity E-5.

| *Content Search Engine*
| Elasticsearch-basierte Komponente zur Indexierung und Volltextsuche √ºber alle Templates und Bausteine. Genutzt von blocpress-workbench.

| *Deterministische Generierung*
| Eigenschaft, dass identische Eingaben (Template-Version + JSON-Daten) immer identische Ausgabedokumente erzeugen. Essentiell f√ºr Regressionstests.

| *Dokumentengenerierung*
| Prozess der automatisierten Bef√ºllung eines Templates mit JSON-Daten (Merge via blocpress-core) und Export als ODT/PDF/RTF (Format-Konvertierung via LibreOffice in blocpress-render). Entity E-3, TF-5.

| *Freigabeprozess*
| Workflow zur Qualit√§tssicherung von Templates: Eingereicht ‚Üí In Pr√ºfung ‚Üí Freigegeben/Abgelehnt. Gesteuert von blocpress-proof. Entity E-4, UC-8, UC-9.

| *IF-Bedingung*
| Bedingung in einem Template, die Inhalte basierend auf JSON-Daten dynamisch ein- oder ausblendet.

| *Dynamic Import*
| JavaScript `import()`-Ausdruck zum dynamischen Laden von ES-Modulen zur Laufzeit. Verwendet von blocpress-studio zum Laden der Web Component-Bundles von den jeweiligen SCS-Modulen.

| *LibreOffice headless*
| LibreOffice-Installation ohne grafische Oberfl√§che, die √ºber UNO-API programmgesteuert bedient wird. Version ‚â• 24 erforderlich. Eingesetzt ausschlie√ülich in blocpress-render f√ºr Format-Export (ODT ‚Üí PDF/RTF). Validierung und Merge laufen √ºber blocpress-core ohne LibreOffice.

| *Message Queue*
| RabbitMQ oder Kafka zur asynchronen Verarbeitung zeitaufw√§ndiger Operationen (Dokumentengenerierung, Regressionstests).

| *Micro-Frontend*
| Architekturmuster, bei dem die UI eines SCS-Moduls als eigenst√§ndige Einheit (Web Component) in eine gemeinsame Portal-Shell integriert wird.

| *ODT*
| OpenDocument Text Format - Standardformat f√ºr LibreOffice-Textdokumente. Template-Eingabeformat f√ºr blocpress.

| *Pr√ºfer*
| Konsolidierte Rolle: Vereint Qualit√§tsmanager, Freigeber, Test-Manager und Compliance-Reviewer. Arbeitet in blocpress-proof.

| *Punkt-Notation*
| Notation zur Referenzierung von JSON-Pfaden in User-Fields, z.B. `kunde.name` oder `vertrag.positionen[0].preis`.

| *Regressionstest*
| Automatisierter Test, der pr√ºft, ob Template-√Ñnderungen ungewollte Auswirkungen auf generierte Dokumente haben. Ausgef√ºhrt in blocpress-proof. UC-16, TF-6.

| *Self-Contained System (SCS)*
| Architekturmuster: Unabh√§ngig deploybare Einheit mit eigener UI, eigenem Backend und eigener Datenhaltung. blocpress besteht aus f√ºnf SCS.

| *Storage Abstraction Layer*
| Interface (`StorageService`) zur Entkopplung von Bin√§rdaten-Speicherung. Erm√∂glicht Wechsel von PostgreSQL bytea zu S3. Wird in jedem SCS-Modul eingesetzt.

| *Stufen√ºbergabe*
| Kopie-basierte √úberf√ºhrung von Templates zwischen Datenstufen: workbench ‚Üí proof (zur Pr√ºfung) ‚Üí production (nach Freigabe). Optional: Baseline-Pull von production ‚Üí proof f√ºr turnusm√§√üige Erneuerung.

| *Template*
| LibreOffice-Dokument (ODT) mit Platzhaltern (User-Fields), Wiederholungsgruppen und Bedingungen. Existiert in drei Stufen (workbench/proof/production). Entity E-1.

| *Test Case*
| Testfall f√ºr ein Template mit JSON-Testdaten und Baseline-PDF. Verwaltet in blocpress-proof. Entity E-6.

| *Testpool*
| Sammlung von Test Cases f√ºr gemeinsame Ausf√ºhrung (z.B. alle Tests f√ºr ein Template). Verwaltet in blocpress-proof. Entity E-7.

| *User-Field*
| Platzhalter in einem Template, der durch JSON-Daten bef√ºllt wird. Name in Punkt-Notation (z.B. `kunde.name`).

| *Vier-Augen-Prinzip*
| Sicherheitskonzept: Template-Designer darf nicht gleichzeitig Freigeber sein. Technisch erzwungen in TF-2 (blocpress-proof).

| *Web Component*
| Browser-Standard (Custom Elements + Shadow DOM) f√ºr wiederverwendbare UI-Komponenten. Jedes SCS-Modul liefert seine UI als Web Component (z.B. `<bp-workbench>`), die von blocpress-studio geladen wird.

| *Wiederholungsgruppe*
| Section oder Table in einem Template, die f√ºr jedes Element eines JSON-Arrays dupliziert und bef√ºllt wird.

| *Workflow-Engine*
| Komponente in blocpress-proof zur Steuerung von Freigabeprozessen und Status√ºberg√§ngen. Pr√ºft Berechtigungen und Vier-Augen-Prinzip.
|===

<<<<

== √úber arc42

arc42, das Template zur Dokumentation von Software- und
Systemarchitekturen.

Template Version 8.2 DE. (basiert auf AsciiDoc Version)
Erstellt, gepflegt und ¬© von Dr. Peter Hruschka, Dr. Gernot Starke und
Mitwirkenden. Siehe https://arc42.org.

=== Lizenz

arc42 is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.

image::https://licensebuttons.net/l/by-sa/4.0/88x31.png[CC BY-SA 4.0]

Weitere Informationen: https://creativecommons.org/licenses/by-sa/4.0/

Under this license, you're free to:

* *Share:* copy and redistribute the material in any medium or format
* *Adapt:* remix, transform, and build upon the material for any purpose, even commercially.

We, the licensors, (Gernot Starke and Peter Hruschka, the creators of arc42) cannot (and surely will not) revoke these freedoms as long as you follow the license terms.

*You must:*

* Give *appropriate credit*, provide a link to the license, and indicate if changes to arc42 were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.
* If you remix, transform, or build upon material from arc42, you must distribute your contributions under the *same license* as the original.

*Attribution for this document:*

This architecture documentation for blocpress is based on the arc42 template by Dr. Gernot Starke and Dr. Peter Hruschka. The template structure follows arc42 Version 8.2 DE. Content specific to blocpress has been created and adapted for this project.

arc42 template: https://arc42.org +
License: https://creativecommons.org/licenses/by-sa/4.0/