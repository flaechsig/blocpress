ifndef::imagesdir[:imagesdir: docs/images]

image:blocpress-logo-large.png[]

= Blocpress – ODT to PDF Document Rendering Engine (Java + LibreOffice)

Blocpress is an open-source Java-based document template engine that renders LibreOffice ODT templates into PDF and RTF using a REST API. It enables dynamic document generation for enterprise workflows.

Its goal is simple: take a LibreOffice Writer template (ODT) plus business data (JSON) and produce a final document with as little “magic” as possible.

== Use Cases

- Render LibreOffice ODT templates to PDF
- Generate dynamic documents from JSON data
- Automate enterprise document workflows
- Headless document generation via REST API

Blocpress treats ODT as the source of truth for layout and formatting. Rendering focuses on:

* replacing placeholders with data,
* showing/hiding conditional content,
* repeating sections/rows for arrays,
* inlining external ODT text blocks.

== License

Apache License, Version 2.0

== Quick start

Render an ODT template from a File and a JSON payload:

=== Requirements

* Java 21+
* LibreOffice / ODT templates created with LibreOffice Writer.

=== Template Writing

A template is a 'simple' LibreOffice ODT file.
You use **User Fields** to mark the places for replacement.
To open the dialog for defining user fields just press CTRL+F2

.Field Dialog View (CTRL+F2)
image::fields_dialog.png[Fields Dialog (CTRL+F2)]

* **Variables** The Variable-Panel contains the **User Field**
* **Type** User Field is mandatory.
No other types are supported for replacement.
* **Select** Already defined user fields for usage.
A user field can be used many times
* **Format** The Format of the user field
* **Name** The name of the user field follows the Dot-Notation
* **Value** Sample value for the document.
Make it easier to read and help design the layout

In the document you can toggle (CTRL+F9) between the **field value view** and the **field name view**.
That makes life quite easier ;-)

.Field Value View in LibreOffice
image::field_value_view.png[Field Value View]

.Field Name View in LibreOffice
image::field_name_view.png[Field Name View]

The prepared Document can be found link:docs/samples/sample-01.odt[Download the sample odt]

=== Java Code

.Structure of the java project
image::projectstructure.png[Project structure]

[source,xml]
----
<dependency>
    <artifactId>blocpress-core</artifactId>
    <groupId>io.github.flaechsig</groupId>
    <version>1.0.0</version>
</dependency>
----

[source,java]
----
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.github.flaechsig.blocpress.core.RenderEngine;

import java.nio.file.Files;
import java.nio.file.Path;

public class ShortestExampleEver {
    static void main(String[] args) throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        Path baseDir = Path.of(System.getProperty("user.dir"));
        Path template = baseDir.resolve("src/main/resources/sample-01.odt");
        Path outputFile = baseDir.resolve("target/output.odt");

        JsonNode data = mapper.readTree("""
                      {
                        "customer": {
                          "firstName": "John",
                          "lastName": "Doe",
                          "address": {
                            "street": "adessoplatz 1",
                            "postcode": "44269",
                            "city": "Dortmund"
                          },
                          "contact": {
                            "email": "john.doe@example.com",
                          }
                        }
                      }
                      """);
        byte[] output = RenderEngine.renderTemplate(template.toUri().toURL(), data);
        Files.write(outputFile, output);
    }
}
----

== Template concepts

=== What is a LibreOffice “print template”?

A template is a regular `.odt` file with placeholders and a small amount of control logic.
During rendering, placeholders are replaced with values from the JSON input and certain document parts (for example sections) can be shown/hidden based on conditions.

=== Placeholders: a single value from JSON

In the template, place a field (a **User Field**) whose name matches a JSON path.

Conceptually:

* Field name in the template: `customer.lastName`

[source,json]
----
{
  "customer": {
    "firstName": "Michael",
    "lastName": "Miller",
    "address": {
      "street": "Example Street 1",
      "postcode": "12345",
      "city": "Hamburg"
    },
    "contact": {
      "email": "michael.miller@example.com"
    }
  }
}
----

Result in the document: `Miller` as shown in the example above.

=== Conditions: show/hide content

Templates can contain conditional elements.
At render time blocpress evaluates the condition against the JSON input and keeps/removes (or resolves) the element accordingly.

Typical use cases:

* greetings (Mr/Ms),
* optional paragraphs,
* product-dependent clauses.

TIP: Keep conditions simple and test them with unit tests.

==== Conditional Text

For the next examples the JSON data has an additional element **gender** with the values **MALE** or **FEMALE**

[source,json]
----
{
  "customer": {
    "gender": "MALE",
    "firstName": "Michael",
    "lastName": "Miller",
    "address": {
      "street": "Example Street 1",
      "postcode": "12345",
      "city": "Hamburg"
    },
    "contact": {
      "email": "michael.miller@example.com"
    }
  }
}
----

For usage the new **User Field** customer.gender will be defined.
We only define the **User Field**.
So we click only **Apply** and not **Insert**.

.Definition of the **User Field** customer.gender
image::user_field_gender.png[Define User Field customer.gender]

Now we can use the **User Field** in the panel **Functions** and define the salutation in dependency of the gender.

.Definition of a **Conditional text**
image::conditional_text_customer_gener.png[Conditional text customer.gender]

If you change the customer.gender in the **Variables** then you must press F9 to refresh all **User Field**s in the Document.

To edit the **Conditional text** is a little bit tricky.
You don't have an overview in the **Functions**-Panel.
You have to open the **Edit Fields ...** in the context menu of the field.

The complete document for **Conditional text** is in link:docs/samples/sample-02.odt[Download the sample-02.odt]

Other possibilities for **Conditional text** **Hidden text** and **Hidden Paragraph**.
Try it on your own.

=== Arrays / lists in JSON data

If the JSON contains arrays (for example multiple persons or line items), you can access the data in two ways.

==== Access on an single element in the list

Again, we expand our example data.

[source,json]
----
{
  "customer": [
      {
        "gender": "MALE",
        "firstName": "Michael",
        "lastName": "Miller",
        "address": {
          "street": "Example Street 1",
          "postcode": "12345",
          "city": "Hamburg"
        },
        "contact": {
          "email": "michael.miller@example.com"
        }
      },
      {
        "gender": "FEMALE",
        "firstName": "Mini",
        "lastName": "Müller",
        "address": {
          "street": "Main Street 1",
          "postcode": "54321",
          "city": "Munich"
        },
        "contact": {
          "email": "mini.miller@example.com"
        }
      }
    ]
}
----

For the to the first customer (Michael Miller) an index after the path element **customer** is added.
The index is 0-based, so the access to the first name of the first customer is **customer.0.firstName**.

.Index access in the field dialog
image::user_field_customer_index.png[]

It is a good idea to know the structure before designing the template, because you must duplicate the elements and remove the old one.

==== Access all data of the list

The second use case processes the complete list.
For this case we have two mechanisms **Sections** and **Tables**.
Both mechanisms are shown in this example. We use the data from the previous exercise.

The definition is straightforward. Don't use an index and the data will be treated as a list. In the next three pictures you see the **Field Value View**, **Field Name View** and the result.

.Field Value View
image::section_with_field_data_view.png[]

The picture shows the definition of the section. In the section you use the data field as shown above. The section itself is inserted with **Insert > Sections...** menu.

.Field Name View
image::field_name_view_with table.png[]

In the second view you see why it is useful to have a value view. The layout is destroyed, but you can see the definition of each single **User Field**. The fields use an index to reference a single entry off the list. In the lower part the index is missing an the data will be treated as list. The result is shown in the next figure

.Result of the rendering process
image::list_result.png[]

=== Text blocks / imported templates (inline expansion)

Until now, we work on only one document. With text block it is possible to maintain central documents (e.g. Terms & Conditions). There is no need to update each Template if there are modifications in this central document. You only modify the generic document, and with the next render process the updated document will be included.

The blocpress way to do this with **Section**s.

.Inserting a text block
image::text_block.png[]

There are two interesting parts in this kind of section definition:

. **Section name**: The section name has a syntax of a function. There is a name parameter. The name do we use in a later release of blocpress. The name is a unique identifier for a central template repository. The parameters are a replacement mechanism for data names the part on the left side will be replaced by the one on the right side.
. **File name**: The file name is for local development. The base directory is the directory of the master document (this is the document that includes text blocks). The name you see is not really the truth. For development time the file must be reachable by LibreOffice for display purposes. At render time the renderer search for the text block in the directory of the master or in one of the parent directories.

In the figure you see "Max Mustermann". At development time the value of **User Field**s are not updated with the **User Field**s from the master document. This will only happen in the rendering process. The result is showing in the next figure.

.Complete document with single fields, lists and text blocks
image::text_block_processed.png[]

